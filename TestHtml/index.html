<!--00:06 1104 æ›´æ–°è‡³ä¸€é€²ä¸€å‡ºåŠŸèƒ½å®Œæˆ -->
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹æ©Ÿé™€èºå„€åµæ¸¬å™¨ v2.0 - æ–æ™ƒåµæ¸¬ç‰ˆ</title>
    <!-- å¼•å…¥ GSAP æ ¸å¿ƒåº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <!-- å¼•å…¥ GSAP Draggable æ’ä»¶ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/Draggable.min.js"></script>
    <!-- å¼•å…¥ jQuery åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <!-- 8th Wall WebAR Pipeline SDK (2024-2026 æœ€æ–°ç‰ˆæœ¬) -->
    <script async src="https://apps.8thwall.com/xrweb?appKey=YOUR_APP_KEY"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
            overflow: hidden;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .status {
            text-align: center;
            margin-bottom: 30px;
            padding: 15px;
            border-radius: 10px;
            font-size: 1.2em;
            font-weight: bold;
        }
        
        .status.supported {
            background: rgba(76, 175, 80, 0.3);
            border: 2px solid #4CAF50;
        }
        
        .status.not-supported {
            background: rgba(244, 67, 54, 0.3);
            border: 2px solid #f44336;
        }
        
        .data-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .data-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .data-card h3 {
            margin: 0 0 15px 0;
            font-size: 1.3em;
            color: #FFD700;
        }
        
        .shake-detected {
            background: linear-gradient(45deg, #FF6B6B, #FF8E8E) !important;
            animation: shakePulse 0.5s ease-in-out;
        }
        
        @keyframes shakePulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        @keyframes shakePulseStrong {
            0% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.08) rotate(-1deg); }
            50% { transform: scale(1.12) rotate(1deg); }
            75% { transform: scale(1.08) rotate(-0.5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }
        
        @keyframes shakePulseIntense {
            0% { transform: scale(1) rotate(0deg); }
            20% { transform: scale(1.1) rotate(-2deg); }
            40% { transform: scale(1.15) rotate(2deg); }
            60% { transform: scale(1.1) rotate(-1deg); }
            80% { transform: scale(1.05) rotate(1deg); }
            100% { transform: scale(1) rotate(0deg); }
        }
        
        @keyframes shakeDemo {
            0% { transform: rotateX(0deg) rotateY(0deg); }
            25% { transform: rotateX(15deg) rotateY(15deg); }
            50% { transform: rotateX(-10deg) rotateY(-10deg); }
            75% { transform: rotateX(10deg) rotateY(-15deg); }
            100% { transform: rotateX(0deg) rotateY(0deg); }
        }
        
        .data-value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .unit {
            font-size: 0.8em;
            opacity: 0.8;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .chart {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .chart-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, #FF6B6B, #4ECDC4, #45B7D1);
            transition: all 0.1s ease;
        }
        
        .instructions {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid #FFD700;
        }
        
        .instructions h3 {
            margin-top: 0;
            color: #FFD700;
        }
        
        .instructions ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .instructions li {
            margin: 8px 0;
            line-height: 1.5;
        }
        
        .deploy-info {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid #4CAF50;
        }
        
        .deploy-info h3 {
            margin-top: 0;
            color: #4CAF50;
        }
        
        .url-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 1.1em;
            word-break: break-all;
        }

        /* ç«‹æ–¹é«”åŠŸèƒ½å€å¡Š */
        .cube-feature {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid #FF6B6B;
        }

        .cube-feature h3 {
            margin-top: 0;
            color: #FF6B6B;
            font-size: 1.5em;
            margin-bottom: 15px;
        }

        .cube-preview {
            display: flex;
            align-items: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .cube-mini {
            width: 80px;
            height: 80px;
            position: relative;
            transform-style: preserve-3d;
            animation: miniRotate 4s infinite linear;
        }

        .cube-mini .face {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .cube-mini .face.front { background: linear-gradient(135deg, #FF6B6B, #FF8E8E); transform: translateZ(40px); }
        .cube-mini .face.back { background: linear-gradient(135deg, #4ECDC4, #7EDDDD); transform: translateZ(-40px) rotateY(180deg); }
        .cube-mini .face.right { background: linear-gradient(135deg, #45B7D1, #6BC5D8); transform: rotateY(90deg) translateZ(40px); }
        .cube-mini .face.left { background: linear-gradient(135deg, #96CEB4, #B8E6B8); transform: rotateY(-90deg) translateZ(40px); }
        .cube-mini .face.top { background: linear-gradient(135deg, #FFEAA7, #FFF2CC); transform: rotateX(90deg) translateZ(40px); }
        .cube-mini .face.bottom { background: linear-gradient(135deg, #DDA0DD, #E6B8E6); transform: rotateX(-90deg) translateZ(40px); }

        @keyframes miniRotate {
            from { transform: rotateX(0deg) rotateY(0deg); }
            to { transform: rotateX(360deg) rotateY(360deg); }
        }

        @keyframes screenCapture {
            0% { transform: rotateX(0deg) rotateY(0deg) scale(1); }
            25% { transform: rotateX(15deg) rotateY(15deg) scale(1.05); }
            50% { transform: rotateX(-10deg) rotateY(-10deg) scale(1.1); }
            75% { transform: rotateX(10deg) rotateY(-15deg) scale(1.05); }
            100% { transform: rotateX(0deg) rotateY(0deg) scale(1); }
        }

        .cube-info {
            flex: 1;
            min-width: 200px;
        }

        .cube-info h4 {
            color: #FFD700;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .cube-info p {
            margin: 8px 0;
            line-height: 1.5;
            opacity: 0.9;
        }

        .cube-link {
            display: inline-block;
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            text-decoration: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: bold;
            margin-top: 15px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .cube-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .feature-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .feature-item .icon {
            font-size: 2em;
            margin-bottom: 10px;
            display: block;
        }

        .feature-item h5 {
            color: #4ECDC4;
            margin-bottom: 8px;
        }

        .feature-item p {
            font-size: 0.9em;
            opacity: 0.8;
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .data-grid {
                grid-template-columns: 1fr;
            }
            
            .cube-preview {
                flex-direction: column;
                text-align: center;
            }
            
            .cube-mini {
                margin: 0 auto 20px auto;
            }
            
            .feature-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .cube-link {
                display: block;
                text-align: center;
                margin: 20px auto 0 auto;
                max-width: 200px;
            }
        }
    </style>
</head>
<body>
    <!-- å¯¼èˆªæ  -->
    <nav style="position: fixed; top: 0; left: 0; right: 0; z-index: 10000; background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(10px); padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">
        <a href="position-test.html" style="text-decoration: none; padding: 12px 24px; border-radius: 25px; font-weight: bold; color: #ffffff; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); transition: all 0.3s ease; display: inline-block;">
            ğŸ“ ä½ç§»æµ‹è¯•
        </a>
        <div style="color: rgba(255,255,255,0.8); font-size: 14px;">æ‰‹æœºé™€èºä»ªæ£€æµ‹å™¨ v2.0</div>
    </nav>
    
    <div id="playOverlay" class="play-overlay" style="position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: radial-gradient(120% 120% at 50% 0%, rgba(255,255,255,0.18) 0%, rgba(0,0,0,0.35) 60%), linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); z-index: 9999;">
        <button id="playButton" class="play-button" style="appearance: none; border: none; cursor: pointer; padding: 16px 42px; border-radius: 999px; font-size: 22px; letter-spacing: 2px; font-weight: 800; color: #ffffff; background: linear-gradient(135deg, #ff8a00 0%, #e52e71 100%); box-shadow: 0 10px 30px rgba(229,46,113,0.45), inset 0 1px 0 rgba(255,255,255,0.25); transition: transform .15s ease, box-shadow .2s ease; text-transform: uppercase;">
            PLAY
        </button>
    </div>
    <div class="container" style="background: none; box-shadow: none; border: none; padding: 0; margin: 0; max-width: none; width: 100vw; min-height: 100vh; display: flex; justify-content: center; align-items: center; overflow: hidden;">
        <h1 style="display: none;">ğŸ¯ æ—‹è½‰æ§åˆ¶å™¨</h1>
        <div style="display: none; text-align: center; margin-bottom: 20px; font-size: 1.2em; color: #FFD700;">
            ğŸ® æ‹–æ‹½æ—‹è½‰æ§åˆ¶ | éŸ³æ•ˆéœ‡å‹•å›é¥‹ | Unity å³æ™‚åŒæ­¥
        </div>
        
        <div id="status" class="status" style="display: none;">
            æ­£åœ¨æª¢æŸ¥é™€èºå„€æ”¯æ´...
        </div>
        
        <div class="data-grid" style="display: none;">
            <div class="data-card">
                <h3>X è»¸ (Alpha)</h3>
                <div id="alpha" class="data-value">0.00</div>
                <div class="unit">åº¦ (0-360)</div>
            </div>
            
            <div class="data-card">
                <h3>Y è»¸ (Beta)</h3>
                <div id="beta" class="data-value">0.00</div>
                <div class="unit">åº¦ (-180 åˆ° 180)</div>
            </div>
            
            <div class="data-card">
                <h3>Z è»¸ (Gamma)</h3>
                <div id="gamma" class="data-value">0.00</div>
                <div class="unit">åº¦ (-90 åˆ° 90)</div>
            </div>
            
            <div class="data-card">
                <h3>æ–æ™ƒåµæ¸¬</h3>
                <div id="shake-status" class="data-value">éœæ­¢</div>
                <div class="unit">ç‹€æ…‹</div>
            </div>
            
            <div class="data-card">
                <h3>æ–æ™ƒæ¬¡æ•¸</h3>
                <div id="shake-count" class="data-value">0</div>
                <div class="unit">æ¬¡</div>
            </div>
            
            <div class="data-card">
                <h3>åŠ é€Ÿåº¦å¼·åº¦</h3>
                <div id="acceleration-magnitude" class="data-value">0.00</div>
                <div class="unit">m/sÂ²</div>
            </div>
            
            <div class="data-card">
                <h3>æ–æ™ƒå¼·åº¦</h3>
                <div id="shake-intensity" class="data-value">éœæ­¢</div>
                <div class="unit">ç‹€æ…‹</div>
            </div>
        </div>
        
        <div class="chart-container" style="display: none;">
            <h3 style="text-align: center; margin-top: 0; color: #FFD700;">å³æ™‚æ•¸æ“šåœ–è¡¨</h3>
            <div class="chart" id="chart">
                <div class="chart-line" id="alpha-line" style="top: 33%; background: #FF6B6B;"></div>
                <div class="chart-line" id="beta-line" style="top: 50%; background: #4ECDC4;"></div>
                <div class="chart-line" id="gamma-line" style="top: 66%; background: #45B7D1;"></div>
            </div>
        </div>
        
        <div class="cube-feature" style="display: none;">
            <h3>ğŸ†• v2.0 æ–°åŠŸèƒ½ï¼šæ™ºèƒ½æ–æ™ƒåµæ¸¬</h3>
            
            <div class="cube-preview">
                <div class="cube-mini" style="animation: shakeDemo 2s infinite ease-in-out;">
                    <div class="face front">æ–</div>
                    <div class="face back">æ™ƒ</div>
                    <div class="face right">åµ</div>
                    <div class="face left">æ¸¬</div>
                    <div class="face top">v2</div>
                    <div class="face bottom">.0</div>
                </div>
                
                <div class="cube-info">
                    <h4>ğŸ¯ ç²¾æº–æ–æ™ƒåµæ¸¬ç³»çµ±</h4>
                    <p><strong>åŸºæ–¼åŠ é€Ÿåº¦æ„Ÿæ¸¬å™¨çš„æ™ºèƒ½æ–æ™ƒåµæ¸¬</strong></p>
                    <p>â€¢ ä½¿ç”¨æ¨™æº–æ¼”ç®—æ³•ï¼šåŠ é€Ÿåº¦è®ŠåŒ–é‡ + é€£çºŒæª¢æ¸¬</p>
                    <p>â€¢ ä¸‰ç´šå¼·åº¦åˆ†é¡ï¼šä¸€èˆ¬æ–æ™ƒã€å¼·çƒˆæ–æ™ƒã€åŠ‡çƒˆæ–æ™ƒ</p>
                    <p>â€¢ é˜²èª¤åˆ¤æ©Ÿåˆ¶ï¼šé€£çºŒ3æ¬¡è¶…æ¨™æ‰è§¸ç™¼</p>
                    <p>â€¢ å³æ™‚è¦–è¦ºå›é¥‹ï¼šå‹•ç•«æ•ˆæœ + å¼·åº¦æŒ‡ç¤º</p>
                </div>
            </div>
            
            <div class="feature-grid">
                <div class="feature-item">
                    <span class="icon">ğŸ“Š</span>
                    <h5>ç²¾æº–é–¾å€¼</h5>
                    <p>10-15 m/sÂ² æ¨™æº–é–¾å€¼</p>
                </div>
                <div class="feature-item">
                    <span class="icon">âš¡</span>
                    <h5>å³æ™‚éŸ¿æ‡‰</h5>
                    <p>æ¯«ç§’ç´šåµæ¸¬å»¶é²</p>
                </div>
                <div class="feature-item">
                    <span class="icon">ğŸ›¡ï¸</span>
                    <h5>é˜²èª¤åˆ¤</h5>
                    <p>é€£çºŒæª¢æ¸¬æ©Ÿåˆ¶</p>
                </div>
                <div class="feature-item">
                    <span class="icon">ğŸ¨</span>
                    <h5>è¦–è¦ºå›é¥‹</h5>
                    <p>å‹•ç•« + é¡è‰²æŒ‡ç¤º</p>
                </div>
            </div>
        </div>
        
        <div class="cube-feature" style="border-left-color: #4ECDC4; display: none;">
            <h3>ğŸ² 3D é™€èºå„€ç«‹æ–¹é«”</h3>
            
            <div class="cube-preview">
                <div class="cube-mini">
                    <div class="face front">å‰</div>
                    <div class="face back">å¾Œ</div>
                    <div class="face right">å³</div>
                    <div class="face left">å·¦</div>
                    <div class="face top">ä¸Š</div>
                    <div class="face bottom">ä¸‹</div>
                </div>
                
                <div class="cube-info">
                    <h4>é«”é©—äº’å‹•å¼3Dç«‹æ–¹é«”</h4>
                    <p>ä½¿ç”¨æ‰‹æ©Ÿé™€èºå„€æ§åˆ¶ä¸€å€‹å…­é¢ä¸åŒé¡è‰²çš„3Dç«‹æ–¹é«”</p>
                    <p>æ¯å€‹é¢éƒ½æœ‰ç¨ç‰¹çš„æ¼¸å±¤è‰²å½©å’Œæ–‡å­—æ¨™è­˜</p>
                    <p>å³æ™‚éŸ¿æ‡‰æ‰‹æ©Ÿçš„æ—‹è½‰å‹•ä½œï¼Œå‰µé€ æ²‰æµ¸å¼3Dé«”é©—</p>
                    <a href="gyroscope-cube.html" class="cube-link">ğŸš€ ç«‹å³é«”é©—</a>
                </div>
            </div>
            
            <div class="feature-grid">
                <div class="feature-item">
                    <span class="icon">ğŸ¨</span>
                    <h5>å…­é¢å½©è‰²</h5>
                    <p>æ¯å€‹é¢éƒ½æœ‰ç¨ç‰¹çš„æ¼¸å±¤è‰²å½©</p>
                </div>
                <div class="feature-item">
                    <span class="icon">ğŸ“±</span>
                    <h5>é™€èºå„€æ§åˆ¶</h5>
                    <p>å³æ™‚éŸ¿æ‡‰æ‰‹æ©Ÿæ—‹è½‰å‹•ä½œ</p>
                </div>
                <div class="feature-item">
                    <span class="icon">ğŸ¯</span>
                    <h5>ç²¾æº–è¿½è¹¤</h5>
                    <p>ä¸‰è»¸æ—‹è½‰æ•¸æ“šå³æ™‚æ›´æ–°</p>
                </div>
                <div class="feature-item">
                    <span class="icon">âœ¨</span>
                    <h5>è¦–è¦ºæ•ˆæœ</h5>
                    <p>3Dé€è¦–å’Œå‹•ç•«æ•ˆæœ</p>
                </div>
            </div>
        </div>
        
        <div class="cube-feature" style="border-left-color: #FF9800; display: none;">
            <h3>ğŸ“º è¢å¹•æ•ç²ä¸²æµ</h3>
            
            <div class="cube-preview">
                <div class="cube-mini" style="animation: screenCapture 3s infinite ease-in-out;">
                    <div class="face front">è¢</div>
                    <div class="face back">å¹•</div>
                    <div class="face right">æ•</div>
                    <div class="face left">ç²</div>
                    <div class="face top">ğŸ“º</div>
                    <div class="face bottom">ä¸²æµ</div>
                </div>
                
                <div class="cube-info">
                    <h4>å³æ™‚è¢å¹•æ•ç²èˆ‡ä¸²æµ</h4>
                    <p>æ•ç²æ•´å€‹è¢å¹•æˆ–ç‰¹å®šè¦–çª—ï¼Œé€éWebSocketå³æ™‚å‚³é€åˆ°Unity</p>
                    <p>æ”¯æ´å…¨è¢å¹•ã€ç‰¹å®šè¦–çª—ã€ç€è¦½å™¨æ¨™ç±¤é æ•ç²</p>
                    <p>WebRTC P2P å„ªå…ˆï¼ŒWebSocket é™ç´šå‚™ç”¨</p>
                    <button id="startScreenCapture" class="cube-link" style="border: none; cursor: pointer;">ğŸ¬ é–‹å§‹æ•ç²</button>
                    <button id="stopScreenCapture" class="cube-link" style="border: none; cursor: pointer; background: linear-gradient(45deg, #f44336, #da190b); display: none;">â¹ï¸ åœæ­¢æ•ç²</button>
                    
                    <div class="webrtc-stats" style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px; font-size: 0.9em;">
                        <h4 style="margin: 0 0 10px 0; color: #FFD700;">å‚³è¼¸ç‹€æ…‹</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                            <div>æ¨¡å¼: <span id="transferMode">æº–å‚™ä¸­</span></div>
                            <div>ç‹€æ…‹: <span id="connectionState">æœªé€£æ¥</span></div>
                            <div>ä½å…ƒç‡: <span id="webrtcBitrate">0 kbps</span></div>
                            <div>å¹€ç‡: <span id="webrtcFPS">0 fps</span></div>
                            <div>RTT: <span id="webrtcRTT">0 ms</span></div>
                            <div>å€™é¸è€…: <span id="webrtcCandidate">unknown</span></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="feature-grid">
                <div class="feature-item">
                    <span class="icon">ğŸ–¥ï¸</span>
                    <h5>å…¨è¢å¹•æ•ç²</h5>
                    <p>æ•ç²æ•´å€‹æ¡Œé¢ç•«é¢</p>
                </div>
                <div class="feature-item">
                    <span class="icon">ğŸªŸ</span>
                    <h5>è¦–çª—é¸æ“‡</h5>
                    <p>é¸æ“‡ç‰¹å®šæ‡‰ç”¨ç¨‹å¼è¦–çª—</p>
                </div>
                <div class="feature-item">
                    <span class="icon">ğŸ“±</span>
                    <h5>å³æ™‚ä¸²æµ</h5>
                    <p>15fpsæµæš¢å‚³è¼¸</p>
                </div>
                <div class="feature-item">
                    <span class="icon">ğŸ¯</span>
                    <h5>Unityæ•´åˆ</h5>
                    <p>ç›´æ¥å‚³é€åˆ°Unityå®¢æˆ¶ç«¯</p>
                </div>
            </div>
            
            <!-- è¢å¹•æ•ç²é è¦½ -->
            <div id="screenCapturePreview" style="display: none; margin-top: 20px;">
                <h4 style="color: #FFD700; margin-bottom: 15px;">ğŸ“± è¢å¹•æ•ç²é è¦½</h4>
                <video id="screenCaptureVideo" autoplay muted style="width: 100%; max-width: 500px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);"></video>
                <div id="screenCaptureStats" style="margin-top: 15px; display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                    <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; text-align: center;">
                        <div style="color: #4ECDC4; font-weight: bold;">ä¸²æµç‹€æ…‹</div>
                        <div id="captureStatus">æœªé–‹å§‹</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; text-align: center;">
                        <div style="color: #4ECDC4; font-weight: bold;">å¹€ç‡</div>
                        <div id="captureFPS">0 FPS</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; text-align: center;">
                        <div style="color: #4ECDC4; font-weight: bold;">æ•¸æ“šå¤§å°</div>
                        <div id="captureDataSize">0 KB</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="spinnerSection" class="cube-feature" style="display: none; justify-content: center; align-items: center; flex-direction: column; gap: 25px; min-height: 70vh; background: none; box-shadow: none; border-left: none; padding: 0; margin: 0; border: none; border-radius: 0;">
            <div class="cube-preview" style="display: block; margin: 0 auto;">
                <div style="position: relative; width: min(300px, 80vw); height: min(300px, 80vw); margin: 0 auto;">
                    <div id="spinKnob" style="width: 100%; height: 100%; cursor: grab;">
                        <img id="spinKnobImage" src="https://i.postimg.cc/mr45tyXJ/Hi-Paint-1760323869267.png" 
                             style="width: 100%; height: 100%; display: block; transform: rotate(-90deg); transform-origin: center;">
                    </div>
                </div>
            </div>
            <div id="spinAngleDisplay" style="margin-top: 20px; font-size: 1.3em; font-weight: bold; color: #FFD700; text-align: center;">
                ç•¶å‰è§’åº¦: 0.0Â°
            </div>
            <div id="spinModeActions" style="width: 100%; text-align: center; margin-top: 0;">
                <button id="selectThisButton" class="cube-link" style="cursor: pointer; display: inline-block; width: auto; padding: 12px 48px;">é¸é€™å°!</button>
                <div id="spinModeStatus" style="margin-top: 16px; font-size: 1.1em; color: #FFD700; font-weight: bold;">ç›®å‰æ¨¡å¼ï¼š120Â° å¸é™„</div>
            </div>
            
            <div class="cube-info" style="display: none;"></div>
            <div class="feature-grid" style="display: none;"></div>
        </div>
        
        <div class="deploy-info" style="display: none;">
            <h3>ğŸš€ å¿«é€Ÿéƒ¨ç½²æ–¹æ¡ˆ</h3>
            <p><strong>æ–¹æ¡ˆä¸€ï¼šNetlifyï¼ˆæ¨è–¦ï¼‰</strong></p>
            <ol>
                <li>å‰å¾€ <a href="https://netlify.com" target="_blank" style="color: #4CAF50;">netlify.com</a></li>
                <li>è¨»å†Š/ç™»å…¥å¸³è™Ÿ</li>
                <li>å°‡æ­¤è³‡æ–™å¤¾æ‹–æ‹½åˆ° "Deploy manually" å€åŸŸ</li>
                <li>ç²å¾— HTTPS ç¶²å€ï¼Œä¾‹å¦‚ï¼š<span class="url-box">https://your-site-name.netlify.app</span></li>
            </ol>
            
            <p><strong>æ–¹æ¡ˆäºŒï¼šVercel</strong></p>
            <ol>
                <li>å‰å¾€ <a href="https://vercel.com" target="_blank" style="color: #4CAF50;">vercel.com</a></li>
                <li>è¨»å†Š/ç™»å…¥å¸³è™Ÿ</li>
                <li>ä¸Šå‚³æ­¤è³‡æ–™å¤¾</li>
                <li>ç²å¾— HTTPS ç¶²å€</li>
            </ol>
            
            <p><strong>æ–¹æ¡ˆä¸‰ï¼šGitHub Pages</strong></p>
            <ol>
                <li>å»ºç«‹ GitHub å„²å­˜åº«</li>
                <li>ä¸Šå‚³æª”æ¡ˆåˆ°å„²å­˜åº«</li>
                <li>åœ¨è¨­å®šä¸­å•Ÿç”¨ GitHub Pages</li>
                <li>ç²å¾—ç¶²å€ï¼š<span class="url-box">https://your-username.github.io/your-repo-name</span></li>
            </ol>
        </div>
        
        <div class="instructions" style="display: none;">
            <h3>ğŸ“‹ v2.0 ä½¿ç”¨èªªæ˜</h3>
            <ul>
                <li><strong>åŸºæœ¬æ“ä½œï¼š</strong>è«‹åœ¨æ‰‹æ©Ÿä¸Šé–‹å•Ÿæ­¤ç¶²é </li>
                <li><strong>æ¬Šé™è¨­å®šï¼š</strong>å…è¨±ç€è¦½å™¨å­˜å–è£ç½®æ„Ÿæ¸¬å™¨ï¼ˆé™€èºå„€ + åŠ é€Ÿåº¦ï¼‰</li>
                <li><strong>é™€èºå„€æ¸¬è©¦ï¼š</strong>æ—‹è½‰æ‰‹æ©Ÿä»¥æŸ¥çœ‹å³æ™‚ä¸‰è»¸æ•¸æ“š</li>
                <li><strong>æ–æ™ƒæ¸¬è©¦ï¼š</strong>ç”¨åŠ›æ–æ™ƒæ‰‹æ©Ÿè§¸ç™¼æ–æ™ƒåµæ¸¬</li>
                <li><strong>è¢å¹•æ•ç²ï¼š</strong>é»æ“Šã€Œé–‹å§‹æ•ç²ã€æŒ‰éˆ•ï¼Œé¸æ“‡è¦æ•ç²çš„è¢å¹•æˆ–è¦–çª—</li>
                <li><strong>æ•¸æ“šèªªæ˜ï¼š</strong>
                    <ul style="margin-top: 10px; padding-left: 20px;">
                        <li>Xè»¸ (Alpha): æ‰‹æ©Ÿç¹Zè»¸æ—‹è½‰ (0-360åº¦)</li>
                        <li>Yè»¸ (Beta): æ‰‹æ©Ÿå‰å¾Œå‚¾æ–œ (-180åˆ°180åº¦)</li>
                        <li>Zè»¸ (Gamma): æ‰‹æ©Ÿå·¦å³å‚¾æ–œ (-90åˆ°90åº¦)</li>
                        <li>æ–æ™ƒåµæ¸¬: åŸºæ–¼åŠ é€Ÿåº¦è®ŠåŒ–é‡ (10+ m/sÂ²)</li>
                        <li>è¢å¹•æ•ç²: æ”¯æ´å…¨è¢å¹•ã€è¦–çª—ã€æ¨™ç±¤é æ•ç²ï¼Œ15fpsä¸²æµ</li>
                    </ul>
                </li>
            </ul>
        </div>
        
        <div class="deploy-info" style="border-left-color: #FF6B6B; display: none;">
            <h3>ğŸ”§ v2.0 æŠ€è¡“è¦æ ¼</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0;">
                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
                    <h4 style="color: #FFD700; margin-top: 0;">æ–æ™ƒåµæ¸¬</h4>
                    <p><strong>æ¼”ç®—æ³•ï¼š</strong>åŠ é€Ÿåº¦è®ŠåŒ–é‡æª¢æ¸¬</p>
                    <p><strong>é–¾å€¼ï¼š</strong>10-15 m/sÂ²</p>
                    <p><strong>é˜²èª¤åˆ¤ï¼š</strong>é€£çºŒ3æ¬¡è¶…æ¨™</p>
                    <p><strong>éŸ¿æ‡‰æ™‚é–“ï¼š</strong>&lt; 100ms</p>
                </div>
                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
                    <h4 style="color: #FFD700; margin-top: 0;">æ„Ÿæ¸¬å™¨æ”¯æ´</h4>
                    <p><strong>é™€èºå„€ï¼š</strong>DeviceOrientationEvent</p>
                    <p><strong>åŠ é€Ÿåº¦ï¼š</strong>DeviceMotionEvent</p>
                    <p><strong>å¹³å°ï¼š</strong>iOS 13+ / Android</p>
                    <p><strong>æ¬Šé™ï¼š</strong>è‡ªå‹•è«‹æ±‚</p>
                </div>
                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
                    <h4 style="color: #FFD700; margin-top: 0;">æ•¸æ“šå‚³è¼¸</h4>
                    <p><strong>å”è­°ï¼š</strong>WebSocket (WSS)</p>
                    <p><strong>é »ç‡ï¼š</strong>å³æ™‚å‚³è¼¸</p>
                    <p><strong>æ ¼å¼ï¼š</strong>JSON</p>
                    <p><strong>æœå‹™å™¨ï¼š</strong>Railway.app</p>
                </div>
                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
                    <h4 style="color: #FFD700; margin-top: 0;">è¦–è¦ºæ•ˆæœ</h4>
                    <p><strong>å‹•ç•«ï¼š</strong>CSS3 å‹•ç•«</p>
                    <p><strong>å›é¥‹ï¼š</strong>é¡è‰² + éœ‡å‹•æ•ˆæœ</p>
                    <p><strong>éŸ¿æ‡‰å¼ï¼š</strong>é©é…å„ç¨®è¢å¹•</p>
                    <p><strong>ä¸»é¡Œï¼š</strong>ç¾ä»£åŒ–è¨­è¨ˆ</p>
                </div>
                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
                    <h4 style="color: #FFD700; margin-top: 0;">è¢å¹•æ•ç²</h4>
                    <p><strong>è§£æåº¦ï¼š</strong>1280x720</p>
                    <p><strong>å¹€ç‡ï¼š</strong>15fps</p>
                    <p><strong>ç·¨ç¢¼ï¼š</strong>JPEG 70%å“è³ª</p>
                    <p><strong>å‚³è¼¸ï¼š</strong>WebSocketå³æ™‚</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // PLAY è¦†è“‹å±¤è¡Œç‚ºï¼šé»æ“Šå¾Œé¡¯ç¤ºè½‰ç›¤
        document.addEventListener('DOMContentLoaded', function() {
            var playBtn = document.getElementById('playButton');
            if (playBtn) {
                playBtn.addEventListener('click', function() {
                    var overlay = document.getElementById('playOverlay');
                    var spinner = document.getElementById('spinnerSection');
                    if (overlay) overlay.style.display = 'none';
                    if (spinner) spinner.style.display = 'flex';
                });
            }
        });

        // æ–æ™ƒåµæ¸¬ç›¸é—œè®Šæ•¸ - åŸºæ–¼æ¨è–¦æ–¹å¼å„ªåŒ–
        let shakeCount = 0;
        let lastShakeTime = 0;
        let lastAcceleration = { x: 0, y: 0, z: 0 };
        let accelerationHistory = [];
        let consecutiveHighAcceleration = 0; // é€£çºŒé«˜åŠ é€Ÿåº¦è¨ˆæ•¸
        
        // é–¾å€¼è¨­å®š - åŸºæ–¼æ¨è–¦çš„æ¨™æº–
        const SHAKE_THRESHOLD = 10; // æ–æ™ƒé–¾å€¼ (m/sÂ²) - æ¨è–¦çš„ 10-12 m/sÂ²
        const INTENSE_SHAKE_THRESHOLD = 15; // åŠ‡çƒˆæ–æ™ƒé–¾å€¼ (m/sÂ²)
        const CONSECUTIVE_SAMPLES = 3; // é€£çºŒè¶…æ¨™æ¨£æœ¬æ•¸ - é¿å…èª¤åˆ¤
        const SHAKE_COOLDOWN = 1000; // æ–æ™ƒå†·å»æ™‚é–“ (æ¯«ç§’)
        const HISTORY_LENGTH = 20; // åŠ é€Ÿåº¦æ­·å²è¨˜éŒ„é•·åº¦
        const GRAVITY = 9.8; // é‡åŠ›åŠ é€Ÿåº¦
        
        // 8th Wall ä¸–ç•Œè¿½è¹¤ç®¡ç†å™¨
        class EighthWallWorldTracker {
            constructor(websocket) {
                this.ws = websocket;
                this.isTracking = false;
                this.lastPosition = null;
                this.initialPosition = null;
                this.isInitialized = false;
            }
            
            // åˆå§‹åŒ– 8th Wall ä¸–ç•Œè¿½è¹¤
            init() {
                // æª¢æŸ¥ XR8 æ˜¯å¦å·²è¼‰å…¥
                if (typeof XR8 === 'undefined') {
                    console.warn('âš ï¸ 8th Wall SDK å°šæœªè¼‰å…¥ï¼Œç­‰å¾…è¼‰å…¥...');
                    // ç­‰å¾… SDK è¼‰å…¥
                    const checkInterval = setInterval(() => {
                        if (typeof XR8 !== 'undefined') {
                            clearInterval(checkInterval);
                            this.startWorldTracking();
                        }
                    }, 100);
                    
                    // 10ç§’è¶…æ™‚
                    setTimeout(() => {
                        if (typeof XR8 === 'undefined') {
                            clearInterval(checkInterval);
                            console.error('âŒ 8th Wall SDK è¼‰å…¥è¶…æ™‚ï¼Œè«‹æª¢æŸ¥ App Key æ˜¯å¦æ­£ç¢º');
                        }
                    }, 10000);
                    return;
                }
                
                this.startWorldTracking();
            }
            
            // å•Ÿå‹•ä¸–ç•Œè¿½è¹¤
            startWorldTracking() {
                if (this.isInitialized) {
                    console.warn('âš ï¸ 8th Wall å·²ç¶“åˆå§‹åŒ–ï¼Œè·³éé‡è¤‡åˆå§‹åŒ–');
                    return;
                }
                
                try {
                    console.log('ğŸš€ å•Ÿå‹• 8th Wall ä¸–ç•Œè¿½è¹¤...');
                    
                    // æ·»åŠ å¿…è¦çš„ pipeline modules
                    XR8.addCameraPipelineModules([
                        XR8.GlTextureRenderer.pipelineModule(),
                        XR8.XrController.pipelineModule(),
                        XR8.RuntimeError.pipelineModule(),
                        XR8.WorldTracking.pipelineModule(),  // ä¸–ç•Œè¿½è¹¤æ ¸å¿ƒæ¨¡çµ„
                    ]);
                    
                    // è‡ªå®šç¾© pipeline module ç²å–ç›¸æ©Ÿ pose
                    XR8.addCameraPipelineModule({
                        name: 'worldpose',
                        onUpdate: ({processCpuResult}) => {
                            this.onCameraUpdate(processCpuResult);
                        }
                    });
                    
                    // ç›£è½ä¸–ç•Œè¿½è¹¤ç‹€æ…‹
                    XR8.addCameraPipelineModule({
                        name: 'worldtrackingstatus',
                        onStart: () => {
                            console.log('âœ… 8th Wall ä¸–ç•Œè¿½è¹¤å·²å•Ÿå‹•');
                            this.isTracking = true;
                        },
                        onDetach: () => {
                            console.log('âš ï¸ 8th Wall ä¸–ç•Œè¿½è¹¤å·²åœæ­¢');
                            this.isTracking = false;
                        }
                    });
                    
                    this.isInitialized = true;
                    console.log('âœ… 8th Wall åˆå§‹åŒ–å®Œæˆ');
                } catch (error) {
                    console.error('âŒ 8th Wall åˆå§‹åŒ–å¤±æ•—:', error);
                }
            }
            
            // è™•ç†ç›¸æ©Ÿä½ç½®æ›´æ–°
            onCameraUpdate(processCpuResult) {
                if (!this.isTracking) return;
                
                const camera = processCpuResult.reality;
                if (!camera || !camera.position || !camera.rotation) {
                    return;
                }
                
                // ç²å–ä½ç½® (X, Y, Z)
                const position = {
                    x: camera.position.x || 0,
                    y: camera.position.y || 0,
                    z: camera.position.z || 0
                };
                
                // ç²å–æ—‹è½‰ (å››å…ƒæ•¸)
                const rotation = {
                    x: camera.rotation.x || 0,
                    y: camera.rotation.y || 0,
                    z: camera.rotation.z || 0,
                    w: camera.rotation.w !== undefined ? camera.rotation.w : 1.0
                };
                
                // è¨ˆç®—ç›¸å°ä½ç§»ï¼ˆç›¸å°æ–¼åˆå§‹ä½ç½®ï¼‰
                let delta = { x: 0, y: 0, z: 0 };
                
                if (this.initialPosition === null) {
                    // è¨˜éŒ„åˆå§‹ä½ç½®
                    this.initialPosition = { ...position };
                    this.lastPosition = { ...position };
                } else {
                    // è¨ˆç®—ç›¸å°åˆå§‹ä½ç½®çš„ä½ç§»
                    delta = {
                        x: position.x - this.initialPosition.x,
                        y: position.y - this.initialPosition.y,
                        z: position.z - this.initialPosition.z
                    };
                    
                    // è¨ˆç®—èˆ‡ä¸Šæ¬¡ä½ç½®çš„å¢é‡ï¼ˆç”¨æ–¼å¹³æ»‘ç§»å‹•ï¼‰
                    const frameDelta = {
                        x: position.x - (this.lastPosition?.x || 0),
                        y: position.y - (this.lastPosition?.y || 0),
                        z: position.z - (this.lastPosition?.z || 0)
                    };
                    
                    // é€é WebSocket ç™¼é€ä½ç½®æ•¸æ“š
                    if (this.ws && this.ws.isConnected) {
                        this.ws.sendPositionData(position, rotation, delta);
                    }
                    
                    this.lastPosition = { ...position };
                }
            }
            
            // é‡ç½®åˆå§‹ä½ç½®
            resetInitialPosition() {
                this.initialPosition = null;
                this.lastPosition = null;
                console.log('ğŸ”„ å·²é‡ç½®åˆå§‹ä½ç½®');
            }
        }
        
        // æª¢æŸ¥æ„Ÿæ¸¬å™¨æ”¯æ´
        function checkSensorSupport() {
            const statusElement = document.getElementById('status');
            let hasOrientation = false;
            let hasAcceleration = false;
            
            // æª¢æŸ¥é™€èºå„€æ”¯æ´
            if (typeof DeviceOrientationEvent !== 'undefined') {
                hasOrientation = true;
            }
            
            // æª¢æŸ¥åŠ é€Ÿåº¦æ„Ÿæ¸¬å™¨æ”¯æ´
            if (typeof DeviceMotionEvent !== 'undefined') {
                hasAcceleration = true;
            }
            
            if (hasOrientation && hasAcceleration) {
                if (typeof DeviceOrientationEvent.requestPermission === 'function' || 
                    typeof DeviceMotionEvent.requestPermission === 'function') {
                    // iOS 13+ éœ€è¦è«‹æ±‚æ¬Šé™
                    statusElement.innerHTML = 'é»æ“Šä»»æ„è™•ä»¥è«‹æ±‚æ„Ÿæ¸¬å™¨æ¬Šé™...';
                    statusElement.className = 'status not-supported';
                    
                    document.addEventListener('click', requestPermissions, { once: true });
                } else {
                    // å…¶ä»–ç€è¦½å™¨ç›´æ¥æ”¯æ´
                    statusElement.innerHTML = 'âœ… é™€èºå„€èˆ‡åŠ é€Ÿåº¦æ„Ÿæ¸¬å™¨æ”¯æ´å·²å•Ÿç”¨';
                    statusElement.className = 'status supported';
                    startSensors();
                }
            } else if (hasOrientation) {
                statusElement.innerHTML = 'âš ï¸ åƒ…æ”¯æ´é™€èºå„€ï¼Œç„¡åŠ é€Ÿåº¦æ„Ÿæ¸¬å™¨';
                statusElement.className = 'status not-supported';
            } else {
                statusElement.innerHTML = 'âŒ æ­¤ç€è¦½å™¨ä¸æ”¯æ´æ„Ÿæ¸¬å™¨åŠŸèƒ½';
                statusElement.className = 'status not-supported';
            }
        }
        
        // è«‹æ±‚æ¬Šé™ (iOS)
        async function requestPermissions() {
            try {
                const statusElement = document.getElementById('status');
                let orientationPermission = 'granted';
                let motionPermission = 'granted';
                
                // è«‹æ±‚é™€èºå„€æ¬Šé™
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    orientationPermission = await DeviceOrientationEvent.requestPermission();
                }
                
                // è«‹æ±‚åŠ é€Ÿåº¦æ„Ÿæ¸¬å™¨æ¬Šé™
                if (typeof DeviceMotionEvent.requestPermission === 'function') {
                    motionPermission = await DeviceMotionEvent.requestPermission();
                }
                
                if (orientationPermission === 'granted' && motionPermission === 'granted') {
                    statusElement.innerHTML = 'âœ… æ„Ÿæ¸¬å™¨æ¬Šé™å·²æˆäºˆ';
                    statusElement.className = 'status supported';
                    startSensors();
                } else {
                    statusElement.innerHTML = 'âŒ æ„Ÿæ¸¬å™¨æ¬Šé™è¢«æ‹’çµ•';
                    statusElement.className = 'status not-supported';
                }
            } catch (error) {
                console.error('æ¬Šé™è«‹æ±‚å¤±æ•—:', error);
                document.getElementById('status').innerHTML = 'âŒ æ¬Šé™è«‹æ±‚å¤±æ•—';
                document.getElementById('status').className = 'status not-supported';
            }
        }
        
        // WebSocketé€£æ¥ç®¡ç†
        class GyroscopeWebSocket {
            constructor() {
                this.ws = null;
                this.isConnected = false;
                this.onConnectedCallback = null;
                this.webrtcCapture = null; // WebRTC å¯¦ä¾‹å¼•ç”¨
                this.room = null;
                this.role = null;
                this.spinLimitReached = false; // æ–°å¢ï¼šæ—‹è½‰ç™¼é€é™åˆ¶
                this.spinModeInfo = {
                    mode: 'default',
                    snapAngle: 120,
                    label: '120Â° å¸é™„'
                };
            }
            
            connect() {
                // é˜²æ­¢é‡è¤‡é€£ç·šï¼šè‹¥å·²é€£ç·šæˆ–æ­£åœ¨é€£ç·šå‰‡ç•¥é
                if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
                    console.log('â„¹ï¸ WebSocket å·²åœ¨é€£ç·šæˆ–é€£ç·šä¸­ï¼Œç•¥éé‡è¤‡é€£ç·š');
                    return;
                }
                const wsUrl = 'wss://testgyroscopehtml-production.up.railway.app';
                console.log('å˜—è©¦é€£æ¥WebSocket:', wsUrl);
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    console.log('âœ… WebSocketé€£æ¥å·²å»ºç«‹');
                    this.isConnected = true;
                    // é€£ä¸Šå³å®£å‘Šæ¶ä½”æ§åˆ¶æ¬Š
                    try {
                        this.ws.send(JSON.stringify({ type: 'claim' }));
                    } catch (_) {}
                    if (this.onConnectedCallback) {
                        this.onConnectedCallback();
                    }
                };
                
                this.ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        
                        // è¢«è¸¢å‡ºé€šçŸ¥
                        if (data.type === 'ejected') {
                            console.warn('âš ï¸ ä½ å·²è¢«æ–°æ§åˆ¶è€…å–ä»£ï¼Œåœæ­¢å‚³é€è³‡æ–™');
                            try {
                                if (typeof this.stopSending === 'function') {
                                    this.stopSending();
                                } else {
                                    if (window.gyroInterval) clearInterval(window.gyroInterval);
                                    if (window.shakeInterval) clearInterval(window.shakeInterval);
                                }
                            } catch (_) {}
                            try { this.ws && this.ws.close(); } catch (_) {}
                            return;
                        }

                        // å–å¾—æ§åˆ¶æ¬Šç¢ºèª
                        if (data.type === 'you-are-controller') {
                            console.log('ğŸ¯ ä½ æ˜¯ç›®å‰æ§åˆ¶è€…ï¼Œå¯ä»¥å‚³é€è³‡æ–™');
                            return;
                        }

                        // è™•ç† ready æ¶ˆæ¯ï¼ˆæˆ¿é–“é…å°å®Œæˆï¼‰
                        if (data.type === 'ready') {
                            console.log('ğŸ¤ æˆ¿é–“é…å°å®Œæˆ:', data.message);
                            // ä¸è¦ returnï¼Œè®“å¾ŒçºŒä¿¡ä»¤ä¹Ÿèƒ½è¢«è™•ç†
                        }
                        
                        // WebRTC åŸç”Ÿä¸‰å‹åˆ¥
                        if (['offer', 'answer', 'candidate'].includes(data.type)) {
                            if (this.webrtcCapture) {
                                this.webrtcCapture.handleSignaling(data);
                            }
                            return;
                        }
                        
                        // æˆ¿é–“åŠ å…¥ç¢ºèª
                        if (data.type === 'joined') {
                            console.log(`âœ… å·²åŠ å…¥æˆ¿é–“: ${data.room} as ${data.role}`);
                            return;
                        }
                        
                        // ä¿ç•™ç¾æœ‰æ¶ˆæ¯è™•ç†
                        if (data.type === 'ack') {
                            console.log('âœ… æ•¸æ“šå·²æˆåŠŸç™¼é€');
                        }
                    } catch (error) {
                        console.error('è§£æWebSocketè¨Šæ¯éŒ¯èª¤:', error);
                    }
                };
                
                this.ws.onclose = (event) => {
                    console.log('âŒ WebSocketé€£æ¥å·²é—œé–‰:', event.code, event.reason);
                    this.isConnected = false;
                };
                
                this.ws.onerror = (error) => {
                    console.error('âŒ WebSocketéŒ¯èª¤:', error);
                };
            }
            
            sendGyroscopeData(alpha, beta, gamma) {
                if (this.isConnected && this.ws && this.ws.readyState === WebSocket.OPEN) {
                    const data = {
                        type: 'gyroscope',
                        alpha: alpha,
                        beta: beta,
                        gamma: gamma,
                        timestamp: Date.now()
                    };
                    console.log('ğŸ“¤ ç™¼é€é™€èºå„€æ•¸æ“š:', data);
                    this.ws.send(JSON.stringify(data));
                }
            }
            
            // ç™¼é€ 8th Wall ä½ç½®æ•¸æ“š
            sendPositionData(position, rotation, delta) {
                if (this.isConnected && this.ws && this.ws.readyState === WebSocket.OPEN) {
                    const data = {
                        type: 'position',
                        data: {
                            position: position,
                            rotation: rotation,
                            delta: delta,
                            timestamp: Date.now()
                        }
                    };
                    console.log('ğŸ“ ç™¼é€ä½ç½®æ•¸æ“š:', data);
                    this.ws.send(JSON.stringify(data));
                }
            }
            
            sendShakeEvent(count, intensity, acceleration, shakeType = 'normal') {
                if (this.isConnected && this.ws && this.ws.readyState === WebSocket.OPEN) {
                    const data = {
                        type: 'shake',
                        data: {
                            count: count,
                            intensity: intensity,
                            acceleration: acceleration,
                            shakeType: shakeType,
                            timestamp: Date.now()
                        }
                    };
                    console.log('ğŸ“¤ ç™¼é€æ–æ™ƒäº‹ä»¶:', data);
                    this.ws.send(JSON.stringify(data));
                }
            }
            
            sendScreenCaptureData(imageData, size) {
                if (this.isConnected && this.ws && this.ws.readyState === WebSocket.OPEN) {
                    // é›™åŒ…å‚³è¼¸ï¼šå…ˆç™¼é€header
                    const header = {
                        type: 'screen_capture_header',
                        clientId: this.clientId || 0,
                        timestamp: Date.now(),
                        size: size
                    };
                    this.ws.send(JSON.stringify(header));
                    
                    // å†ç™¼é€äºŒé€²ä½æ•¸æ“š
                    this.ws.send(imageData);
                    
                    console.log('ğŸ“¤ ç™¼é€è¢å¹•æ•ç²: header + binary data', { 
                        clientId: header.clientId, 
                        size: size, 
                        timestamp: header.timestamp 
                    });
                }
            }
            
            sendSpinMode(mode, snapAngle, label) {
                this.updateSpinModeInfo(mode, snapAngle, label);
                
                console.log('ğŸ”„ sendSpinMode è¢«èª¿ç”¨:', { mode, snapAngle, label, isConnected: this.isConnected, wsState: this.ws?.readyState });
                
                const sendMessage = () => {
                    if (this.isConnected && this.ws && this.ws.readyState === WebSocket.OPEN) {
                        const payload = {
                            type: 'spin_mode',
                            data: {
                                mode: mode || 'default',
                                snapAngle: typeof snapAngle === 'number' ? snapAngle : 120,
                                label: label || (mode === 'selected' ? '90Â° å¸é™„' : '120Â° å¸é™„'),
                                timestamp: Date.now()
                            }
                        };
                        const jsonPayload = JSON.stringify(payload);
                        console.log('ğŸ“¤ æº–å‚™ç™¼é€æ—‹éˆ•æ¨¡å¼è³‡è¨Š:', payload);
                        console.log('ğŸ“¤ JSON å­—ä¸²:', jsonPayload);
                        try {
                            this.ws.send(jsonPayload);
                            console.log('âœ… æ—‹éˆ•æ¨¡å¼è³‡è¨Šå·²æˆåŠŸç™¼é€');
                            return true;
                        } catch (error) {
                            console.error('âŒ ç™¼é€æ—‹éˆ•æ¨¡å¼è³‡è¨Šå¤±æ•—:', error);
                            return false;
                        }
                    }
                    return false;
                };
                
                // å¦‚æœå·²é€£æ¥ï¼Œç«‹å³ç™¼é€
                if (sendMessage()) {
                    return;
                }
                
                // å¦‚æœæœªé€£æ¥ï¼Œç­‰å¾…é€£æ¥å®Œæˆå¾Œå†ç™¼é€ï¼ˆæœ€å¤šç­‰å¾…3ç§’ï¼‰
                console.warn('âš ï¸ WebSocket æœªé€£ç·šï¼Œç­‰å¾…é€£æ¥...', {
                    isConnected: this.isConnected,
                    wsState: this.ws?.readyState,
                    wsExists: !!this.ws
                });
                
                let retryCount = 0;
                const maxRetries = 30; // 3ç§’ï¼Œæ¯100msæª¢æŸ¥ä¸€æ¬¡
                const retryInterval = setInterval(() => {
                    retryCount++;
                    if (sendMessage()) {
                        clearInterval(retryInterval);
                        console.log('âœ… é€£æ¥å®Œæˆå¾ŒæˆåŠŸç™¼é€æ—‹éˆ•æ¨¡å¼è³‡è¨Š');
                    } else if (retryCount >= maxRetries) {
                        clearInterval(retryInterval);
                        console.error('âŒ ç­‰å¾…é€£æ¥è¶…æ™‚ï¼Œç„¡æ³•ç™¼é€æ—‹éˆ•æ¨¡å¼è³‡è¨Š');
                    }
                }, 100);
            }
            
            updateSpinModeInfo(mode, snapAngle, label) {
                this.spinModeInfo = {
                    mode: mode || 'default',
                    snapAngle: typeof snapAngle === 'number' ? snapAngle : 120,
                    label: label || (mode === 'selected' ? '90Â° å¸é™„' : '120Â° å¸é™„')
                };
            }
            
            // æ–°å¢ï¼šè¨­å®š/æŸ¥è©¢æ—‹è½‰é™åˆ¶
            setSpinLimitReached(v) {
                this.spinLimitReached = !!v;
            }

            sendSpinEvent(angle, timestamp) {
                console.log('ğŸ¯ sendSpinEvent è¢«è°ƒç”¨:', { angle, timestamp, isConnected: this.isConnected, wsState: this.ws?.readyState });

                // æ–°å¢ï¼šè‹¥å·²è§¸ç™¼é™åˆ¶å‰‡ä¸å†ç™¼é€
                if (this.spinLimitReached) {
                    console.warn('âš ï¸ å·²é”åˆ°æ—‹è½‰é™åˆ¶ï¼Œåœæ­¢ç™¼é€ spin æ•¸æ“š');
                    return;
                }

                if (this.isConnected && this.ws && this.ws.readyState === WebSocket.OPEN) {
                    const data = {
                        type: 'spin',
                        data: {
                            triggered: true,
                            angle: angle,
                            timestamp: timestamp || Date.now(),
                            snapAngle: this.spinModeInfo?.snapAngle || 120,
                            mode: this.spinModeInfo?.mode || 'default',
                            label: this.spinModeInfo?.label || ''
                        }
                    };
                    console.log('ğŸ“¤ å‘é€æ—‹è½¬äº‹ä»¶:', data);
                    this.ws.send(JSON.stringify(data));
                } else {
                    console.warn('âš ï¸ WebSocketæœªè¿æ¥ï¼Œæ— æ³•å‘é€æ—‹è½¬äº‹ä»¶:', {
                        isConnected: this.isConnected,
                        wsState: this.ws?.readyState
                    });
                }
            }
            
            setOnConnectedCallback(callback) {
                this.onConnectedCallback = callback;
            }
            
            joinRoom(roomId, role) {
                this.room = roomId;
                this.role = role;
                
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'join',
                        room: roomId,
                        role: role
                    }));
                }
            }
            
            send(message) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(message);
                }
            }
        }
        
        // WebRTC è¢å¹•æ•æ‰é¡
        class WebRTCScreenCapture {
            constructor(signalingWS, roomId) {
                this.signalingWS = signalingWS;
                this.roomId = roomId;
                this.peerConnection = null;
                this.localStream = null;
                this.iceOk = false;
                this.t1 = null; // 10ç§’è¶…æ™‚è¨ˆæ™‚å™¨
                this.t2 = null; // 18ç§’é™ç´šè¨ˆæ™‚å™¨
                this.mode = 'WebRTC'; // æˆ– 'WebSocket'
                this.stats = { bitrate: 0, fps: 0, rtt: 0, candidateType: 'unknown' };
                this.statsTimer = null;
                
                // ICE é…ç½®ï¼šåªä½¿ç”¨ STUN
                this.rtcConfig = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' }
                    ],
                    iceCandidatePoolSize: 10
                };
            }
            
            async start() {
                try {
                    console.log('ğŸ¬ å•Ÿå‹• WebRTC è¢å¹•æ•æ‰');
                    
                    // æª¢æŸ¥æ˜¯å¦å·²ç¶“æœ‰æµ
                    if (this.localStream) {
                        console.log('âš ï¸ å·²æœ‰è¢å¹•æµï¼Œé‡è¤‡ä½¿ç”¨');
                        return;
                    }
                    
                    // 1. ç²å–è¢å¹•æµ
                    this.localStream = await navigator.mediaDevices.getDisplayMedia({
                        video: {
                            width: { ideal: 1280 },
                            height: { ideal: 720 },
                            frameRate: { ideal: 30, max: 30 }
                        },
                        audio: false
                    });
                    
                    // 2. è¨­ç½® contentHint
                    const [videoTrack] = this.localStream.getVideoTracks();
                    videoTrack.contentHint = 'text'; // æ–‡å­—æ¸…æ™°å„ªå…ˆ
                    
                    // 3. è¨­ç½®é è¦½ä¸²æµï¼ˆWebRTC è·¯å¾‘ä¹Ÿè¦é¡¯ç¤ºï¼‰
                    const videoEl = document.getElementById('screenCaptureVideo');
                    if (videoEl) {
                        videoEl.srcObject = this.localStream;
                        await videoEl.play();
                        console.log('ğŸ“º WebRTC é è¦½ä¸²æµå·²è¨­ç½®');
                    }
                    document.getElementById('screenCapturePreview').style.display = 'block';
                    document.getElementById('captureStatus').textContent = 'WebRTC ä¸²æµä¸­';
                    
                    // 4. ç›£è½ç”¨æˆ¶åœæ­¢åˆ†äº«
                    videoTrack.onended = () => {
                        console.log('ğŸ“º ç”¨æˆ¶åœæ­¢åˆ†äº«');
                        this.teardown(false);
                    };
                    
                    // 5. å‰µå»º RTCPeerConnection
                    this.peerConnection = new RTCPeerConnection(this.rtcConfig);
                    
                    // 6. æ·»åŠ è»Œé“
                    this.peerConnection.addTrack(videoTrack, this.localStream);
                    
                    // 7. ICE å€™é¸è€…è™•ç†
                    this.peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            this.signalingWS.send(JSON.stringify({
                                type: 'candidate',
                                candidate: event.candidate
                            }));
                        }
                    };
                    
                    // 7. ICE é€£æ¥ç‹€æ…‹ç›£æ§
                    this.peerConnection.oniceconnectionstatechange = () => {
                        const state = this.peerConnection.iceConnectionState;
                        console.log('ğŸ”Œ ICE ç‹€æ…‹:', state);
                        
                        if (state === 'connected' || state === 'completed') {
                            this.iceOk = true;
                            clearTimeout(this.t1);
                            clearTimeout(this.t2);
                            this.updateUI('WebRTC P2P', 'connected');
                        } else if (state === 'failed' || state === 'disconnected') {
                            this.teardown(true);
                        }
                    };
                    
                    // 8. å‰µå»º Offer
                    const offer = await this.peerConnection.createOffer();
                    await this.peerConnection.setLocalDescription(offer);
                    
                    // 9. ç™¼é€ Offer
                    this.signalingWS.send(JSON.stringify({
                        type: 'offer',
                        sdp: offer.sdp
                    }));
                    
                    // 10. è¨­ç½®è¶…æ™‚æ©Ÿåˆ¶
                    this.setupTimeout();
                    
                    // 11. é–‹å§‹ Stats ç›£æ§
                    this.startStatsMonitoring();
                    
                    console.log('âœ… WebRTC Offer å·²ç™¼é€');
                    
                } catch (error) {
                    console.error('âŒ WebRTC å•Ÿå‹•å¤±æ•—:', error);
                    this.teardown(true);
                }
            }
            
            setupTimeout() {
                // T+10sï¼šå¦‚æœé‚„æ²’é€£ä¸Šï¼Œå˜—è©¦ restartIce
                this.t1 = setTimeout(async () => {
                    if (!this.iceOk) {
                        console.warn('âš ï¸ 10ç§’è¶…æ™‚ï¼Œå˜—è©¦ restartIce');
                        try {
                            await this.peerConnection.restartIce();
                        } catch (e) {
                            console.error('restartIce å¤±æ•—:', e);
                        }
                        
                        // T+18sï¼šä»ä¸é€š â†’ é™ç´š
                        this.t2 = setTimeout(() => {
                            if (!this.iceOk) {
                                console.warn('âš ï¸ 18ç§’ä»æœªé€£æ¥ï¼Œé™ç´šåˆ° WebSocket');
                                this.teardown(true);
                            }
                        }, 8000);
                    }
                }, 10000);
            }
            
            async handleSignaling(message) {
                try {
                    if (message.type === 'answer') {
                        const answer = new RTCSessionDescription({
                            type: 'answer',
                            sdp: message.sdp
                        });
                        await this.peerConnection.setRemoteDescription(answer);
                        console.log('âœ… æ”¶åˆ° Answer');
                    } else if (message.type === 'candidate') {
                        const candidate = new RTCIceCandidate(message.candidate);
                        await this.peerConnection.addIceCandidate(candidate);
                        console.log('âœ… æ·»åŠ  ICE å€™é¸è€…');
                    }
                } catch (error) {
                    console.error('âŒ è™•ç†ä¿¡ä»¤å¤±æ•—:', error);
                }
            }
            
            startStatsMonitoring() {
                let last = { bytes: 0, ts: 0, frames: 0 };
                this.statsTimer = setInterval(async () => {
                    if (!this.peerConnection || this.peerConnection.connectionState !== 'connected') return;

                    const stats = await this.peerConnection.getStats();
                    let remoteCand = {}, pair, outbound;

                    stats.forEach(r => {
                        if (r.type === 'candidate-pair' && r.state === 'succeeded') pair = r;
                        if (r.type === 'remote-candidate') remoteCand[r.id] = r;
                        if (r.type === 'outbound-rtp' && r.kind === 'video') outbound = r;
                    });

                    if (outbound) {
                        const now = outbound.timestamp;       // ms
                        const bytes = outbound.bytesSent || 0;
                        const frames = outbound.framesEncoded ?? 0;

                        if (last.ts) {
                            const dt = (now - last.ts) / 1000;  // s
                            const db = bytes - last.bytes;
                            const df = frames - last.frames;
                            this.stats.bitrate = Math.max(0, Math.round((db * 8) / 1000 / dt)); // kbps
                            this.stats.fps = Math.max(0, Math.round(df / dt));
                        }
                        last = { bytes, ts: now, frames };
                    }

                    if (pair) {
                        this.stats.rtt = pair.currentRoundTripTime ? Math.round(pair.currentRoundTripTime * 1000) : 0;
                        // è§£æ candidate typeï¼ˆhost/srflx/relayï¼‰
                        const rcId = pair.remoteCandidateId;
                        const rc = rcId ? remoteCand[rcId] : null;
                        if (rc && rc.candidateType) this.stats.candidateType = rc.candidateType;
                    }

                    this.updateStatsUI();
                }, 2000);
            }
            
            updateStatsUI() {
                const bitrateEl = document.getElementById('webrtcBitrate');
                const fpsEl = document.getElementById('webrtcFPS');
                const rttEl = document.getElementById('webrtcRTT');
                const candidateEl = document.getElementById('webrtcCandidate');
                
                if (bitrateEl) bitrateEl.textContent = `${this.stats.bitrate} kbps`;
                if (fpsEl) fpsEl.textContent = `${this.stats.fps} fps`;
                if (rttEl) rttEl.textContent = `${this.stats.rtt.toFixed(0)} ms`;
                if (candidateEl) candidateEl.textContent = this.stats.candidateType;
            }
            
            updateUI(mode, state) {
                const modeEl = document.getElementById('transferMode');
                const stateEl = document.getElementById('connectionState');
                
                if (modeEl) modeEl.textContent = mode;
                if (stateEl) stateEl.textContent = state;
            }
            
            teardown(fallbackToWS) {
                console.log('ğŸ›‘ æ¸…ç† WebRTC è³‡æº');
                
                // åœæ­¢æ‰€æœ‰è»Œé“
                try {
                    this.localStream?.getTracks().forEach(track => track.stop());
                } catch (e) {}
                
                // åœæ­¢ PeerConnection çš„ senders
                try {
                    this.peerConnection?.getSenders().forEach(sender => {
                        if (sender.track) sender.track.stop();
                    });
                } catch (e) {}
                
                // é—œé–‰ PeerConnection
                try {
                    this.peerConnection?.close();
                } catch (e) {}
                
                // æ¸…ç†è¨ˆæ™‚å™¨
                clearTimeout(this.t1);
                clearTimeout(this.t2);
                clearInterval(this.statsTimer);
                
                this.mode = 'WebSocket';
                
                // é™ç´šåˆ° WebSocket
                if (fallbackToWS) {
                    this.updateUI('WebSocket ä¸­ç¹¼', 'fallback');
                    startWebSocketScreenCapture();
                }
            }
        }
        
        // å»ºç«‹WebSocketå¯¦ä¾‹
        const gyroWS = new GyroscopeWebSocket();
        
        // è¢å¹•æ•ç²ç›¸é—œè®Šæ•¸
        let screenCaptureStream = null;
        let screenCaptureCanvas = null;
        let screenCaptureCtx = null;
        let isScreenCapturing = false;
        let screenCaptureFrameCount = 0;
        let screenCaptureLastTime = Date.now();
        let screenCaptureTotalDataSize = 0;
        
        // WebRTC ç›¸é—œè®Šæ•¸
        let webrtcCapture = null;
        let isUsingWebSocket = false;
        
        // æ–æ™ƒåµæ¸¬æ¼”ç®—æ³• - åŸºæ–¼æ¨è–¦çš„æ¨™æº–æ–¹å¼
        function detectShake(acceleration) {
            const currentTime = Date.now();
            
            // 1. è®€æ„Ÿæ¸¬å™¨æ•¸æ“š â†’ å–æ‰‹æ©Ÿçš„åŠ é€Ÿåº¦ (x, y, z)
            const { x, y, z } = acceleration;
            
            // 2. ç®—åˆæˆåŠ é€Ÿåº¦ â†’ âˆš(xÂ² + yÂ² + zÂ²)
            const currentMagnitude = Math.sqrt(x * x + y * y + z * z);
            
            // 3. å»æ‰é‡åŠ›å½±éŸ¿ â†’ ç”¨è®ŠåŒ–é‡ Î”a
            const deltaX = Math.abs(x - lastAcceleration.x);
            const deltaY = Math.abs(y - lastAcceleration.y);
            const deltaZ = Math.abs(z - lastAcceleration.z);
            const deltaMagnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);
            
            // æ›´æ–°åŠ é€Ÿåº¦æ­·å²
            accelerationHistory.push({
                x: x,
                y: y,
                z: z,
                magnitude: currentMagnitude,
                delta: deltaMagnitude,
                timestamp: currentTime
            });
            
            // é™åˆ¶æ­·å²è¨˜éŒ„é•·åº¦
            if (accelerationHistory.length > HISTORY_LENGTH) {
                accelerationHistory.shift();
            }
            
            // èª¿è©¦è¼¸å‡º
            console.log(`ğŸ” æ–æ™ƒåµæ¸¬: åˆæˆåŠ é€Ÿåº¦=${currentMagnitude.toFixed(2)}, è®ŠåŒ–é‡=${deltaMagnitude.toFixed(2)}, é–¾å€¼=${SHAKE_THRESHOLD}, é€£çºŒ=${consecutiveHighAcceleration}`);
            
            // 4. è¨­é–¾å€¼ â†’ Î”a è¶…é ~10â€“12 m/sÂ² æ‰ç®—ã€ŒåŠ‡çƒˆæ–æ™ƒã€
            const isHighAcceleration = deltaMagnitude > SHAKE_THRESHOLD;
            
            // 5. åŠ ä¸Šæ™‚é–“æ¢ä»¶ â†’ é€£çºŒå¹¾å€‹å–æ¨£è¶…æ¨™æ‰è§¸ç™¼ï¼Œé¿å…èª¤åˆ¤
            if (isHighAcceleration) {
                consecutiveHighAcceleration++;
            } else {
                consecutiveHighAcceleration = 0; // é‡ç½®è¨ˆæ•¸
            }
            
            // æª¢æŸ¥æ˜¯å¦è§¸ç™¼æ–æ™ƒäº‹ä»¶
            if (consecutiveHighAcceleration >= CONSECUTIVE_SAMPLES && (currentTime - lastShakeTime) > SHAKE_COOLDOWN) {
                shakeCount++;
                lastShakeTime = currentTime;
                consecutiveHighAcceleration = 0; // é‡ç½®è¨ˆæ•¸
                
                // åˆ¤æ–·æ–æ™ƒå¼·åº¦
                let shakeType = 'normal';
                let shakeMessage = 'æ–æ™ƒä¸­ï¼';
                
                if (deltaMagnitude >= INTENSE_SHAKE_THRESHOLD) {
                    shakeType = 'intense';
                    shakeMessage = 'åŠ‡çƒˆæ–æ™ƒï¼';
                } else if (deltaMagnitude >= 12) {
                    shakeType = 'strong';
                    shakeMessage = 'å¼·çƒˆæ–æ™ƒï¼';
                }
                
                // æ›´æ–°æ–æ™ƒç‹€æ…‹é¡¯ç¤º
                updateShakeStatus(shakeMessage, true, shakeType);
                
                // é€éWebSocketç™¼é€æ–æ™ƒäº‹ä»¶
                gyroWS.sendShakeEvent(shakeCount, deltaMagnitude, acceleration, shakeType);
                
                // è§¸ç™¼è¦–è¦ºæ•ˆæœ
                triggerShakeEffect(shakeType);
                
                console.log(`ğŸ“³ åµæ¸¬åˆ°${shakeMessage}ç¬¬ ${shakeCount} æ¬¡ï¼Œè®ŠåŒ–é‡: ${deltaMagnitude.toFixed(2)} m/sÂ²ï¼Œé¡å‹: ${shakeType}`);
                
                // æ ¹æ“šæ–æ™ƒå¼·åº¦èª¿æ•´æ¢å¾©æ™‚é–“
                const recoveryTime = shakeType === 'intense' ? 1500 : 1000;
                setTimeout(() => {
                    updateShakeStatus('éœæ­¢', false);
                }, recoveryTime);
                
                return true;
            }
            
            // æ›´æ–°æœ€å¾Œä¸€æ¬¡åŠ é€Ÿåº¦
            lastAcceleration = { x, y, z };
            
            return false;
        }
        
        // æ›´æ–°æ–æ™ƒç‹€æ…‹é¡¯ç¤º
        function updateShakeStatus(status, isShaking, shakeType = 'normal') {
            const statusElement = document.getElementById('shake-status');
            const countElement = document.getElementById('shake-count');
            const intensityElement = document.getElementById('shake-intensity');
            
            statusElement.textContent = status;
            countElement.textContent = shakeCount;
            
            // æ›´æ–°æ–æ™ƒå¼·åº¦é¡¯ç¤º
            if (isShaking) {
                let intensityText = '';
                let intensityColor = '';
                
                switch(shakeType) {
                    case 'intense':
                        intensityText = 'åŠ‡çƒˆ';
                        intensityColor = '#FF4444';
                        break;
                    case 'strong':
                        intensityText = 'å¼·çƒˆ';
                        intensityColor = '#FF8800';
                        break;
                    default:
                        intensityText = 'ä¸€èˆ¬';
                        intensityColor = '#FF6B6B';
                }
                
                intensityElement.textContent = intensityText;
                intensityElement.style.color = intensityColor;
            } else {
                intensityElement.textContent = 'éœæ­¢';
                intensityElement.style.color = '#4ECDC4';
            }
            
            // æ·»åŠ æ–æ™ƒæ•ˆæœ
            if (isShaking) {
                statusElement.parentElement.classList.add('shake-detected');
                
                // æ ¹æ“šæ–æ™ƒé¡å‹æ·»åŠ ä¸åŒçš„è¦–è¦ºæ•ˆæœ
                if (shakeType === 'intense') {
                    statusElement.parentElement.style.background = 'linear-gradient(45deg, #FF4444, #FF6666)';
                } else if (shakeType === 'strong') {
                    statusElement.parentElement.style.background = 'linear-gradient(45deg, #FF8800, #FFAA44)';
                } else {
                    statusElement.parentElement.style.background = 'linear-gradient(45deg, #FF6B6B, #FF8E8E)';
                }
                
                setTimeout(() => {
                    statusElement.parentElement.classList.remove('shake-detected');
                    statusElement.parentElement.style.background = '';
                }, 500);
            }
        }
        
        // è§¸ç™¼æ–æ™ƒè¦–è¦ºæ•ˆæœ
        function triggerShakeEffect(shakeType = 'normal') {
            let animationDuration = '0.3s';
            let animationIntensity = 'shakePulse';
            
            // æ ¹æ“šæ–æ™ƒé¡å‹èª¿æ•´å‹•ç•«æ•ˆæœ
            if (shakeType === 'intense') {
                animationDuration = '0.5s';
                animationIntensity = 'shakePulseIntense';
            } else if (shakeType === 'strong') {
                animationDuration = '0.4s';
                animationIntensity = 'shakePulseStrong';
            }
            
            document.body.style.animation = `${animationIntensity} ${animationDuration} ease-in-out`;
            setTimeout(() => {
                document.body.style.animation = '';
            }, parseFloat(animationDuration) * 1000);
        }
        
        // é–‹å§‹æ„Ÿæ¸¬å™¨ç›£è½
        function startSensors() {
            // æ­¤è™•ä¸å†é‡è¤‡é€£ç·šï¼Œè¼‰å…¥æ™‚å·²å…ˆå˜—è©¦é€£ç·š
            
            // è¨­ç½®é€£æ¥æˆåŠŸå¾Œçš„å›èª¿
            gyroWS.setOnConnectedCallback(() => {
                console.log('ğŸ¯ WebSocketé€£æ¥æˆåŠŸï¼Œé–‹å§‹æ„Ÿæ¸¬å™¨ç›£è½');
            });
            
            let dataHistory = [];
            const maxHistory = 100;
            
            // é™€èºå„€ç›£è½
            window.addEventListener('deviceorientation', function(event) {
                // æ›´æ–°æ•¸å€¼é¡¯ç¤º
                updateDisplay(event.alpha, event.beta, event.gamma);
                
                // æ›´æ–°åœ–è¡¨
                updateChart(event.alpha, event.beta, event.gamma);
                
                // é€éWebSocketç™¼é€æ•¸æ“š
                gyroWS.sendGyroscopeData(event.alpha, event.beta, event.gamma);
                
                // å„²å­˜æ­·å²æ•¸æ“š
                dataHistory.push({
                    alpha: event.alpha,
                    beta: event.beta,
                    gamma: event.gamma,
                    timestamp: Date.now()
                });
                
                // é™åˆ¶æ­·å²æ•¸æ“šé•·åº¦
                if (dataHistory.length > maxHistory) {
                    dataHistory.shift();
                }
            });
            
            // åŠ é€Ÿåº¦æ„Ÿæ¸¬å™¨ç›£è½
            window.addEventListener('devicemotion', function(event) {
                const acceleration = event.accelerationIncludingGravity;
                
                if (acceleration) {
                    // æ›´æ–°åŠ é€Ÿåº¦å¼·åº¦é¡¯ç¤º
                    const magnitude = Math.sqrt(
                        acceleration.x * acceleration.x + 
                        acceleration.y * acceleration.y + 
                        acceleration.z * acceleration.z
                    );
                    
                    document.getElementById('acceleration-magnitude').textContent = magnitude.toFixed(2);
                    
                    // åŸ·è¡Œæ–æ™ƒåµæ¸¬
                    detectShake(acceleration);
                }
            });
        }
        
        // æ›´æ–°é¡¯ç¤ºæ•¸å€¼
        function updateDisplay(alpha, beta, gamma) {
            document.getElementById('alpha').textContent = formatValue(alpha);
            document.getElementById('beta').textContent = formatValue(beta);
            document.getElementById('gamma').textContent = formatValue(gamma);
        }
        
        // æ ¼å¼åŒ–æ•¸å€¼
        function formatValue(value) {
            if (value === null) return 'N/A';
            return value.toFixed(2);
        }
        
        // æ›´æ–°åœ–è¡¨
        function updateChart(alpha, beta, gamma) {
            const chartWidth = document.getElementById('chart').offsetWidth;
            
            // å°‡è§’åº¦è½‰æ›ç‚ºåœ–è¡¨ä½ç½® (0-100%)
            const alphaPos = ((alpha || 0) / 360) * 100;
            const betaPos = (((beta || 0) + 180) / 360) * 100;
            const gammaPos = (((gamma || 0) + 90) / 180) * 100;
            
            // æ›´æ–°ç·šæ¢ä½ç½®
            document.getElementById('alpha-line').style.left = Math.max(0, Math.min(100, alphaPos)) + '%';
            document.getElementById('beta-line').style.left = Math.max(0, Math.min(100, betaPos)) + '%';
            document.getElementById('gamma-line').style.left = Math.max(0, Math.min(100, gammaPos)) + '%';
        }
        
        // ç­‰å¾… WebSocket é€£æ¥å°±ç·’
        function waitForWebSocketReady() {
            return new Promise((resolve, reject) => {
                if (gyroWS.ws && gyroWS.ws.readyState === WebSocket.OPEN) {
                    resolve();
                    return;
                }
                
                const checkInterval = setInterval(() => {
                    if (gyroWS.ws && gyroWS.ws.readyState === WebSocket.OPEN) {
                        clearInterval(checkInterval);
                        resolve();
                    }
                }, 100);
                
                // 10ç§’è¶…æ™‚
                setTimeout(() => {
                    clearInterval(checkInterval);
                    reject(new Error('WebSocket é€£æ¥è¶…æ™‚'));
                }, 10000);
            });
        }
        
        // ç­‰å¾…æˆ¿é–“é…å°å®Œæˆ
        function waitForRoomReady() {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    console.warn('âš ï¸ æˆ¿é–“é…å°è¶…æ™‚ï¼Œç›´æ¥é–‹å§‹ WebRTC');
                    resolve(); // æ”¹ç‚º resolve è€Œä¸æ˜¯ rejectï¼Œè®“ WebRTC å˜—è©¦é€£æ¥
                }, 10000); // 10ç§’è¶…æ™‚
                
                const messageHandler = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'ready') {
                            console.log('ğŸ¤ æ”¶åˆ°æˆ¿é–“é…å°å®Œæˆé€šçŸ¥:', data.message);
                            clearTimeout(timeout);
                            gyroWS.ws.removeEventListener('message', messageHandler);
                            resolve();
                        }
                    } catch (e) {
                        // å¿½ç•¥è§£æéŒ¯èª¤
                    }
                };
                
                // ç¢ºä¿ WebSocket å·²é€£æ¥
                if (gyroWS.ws && gyroWS.ws.readyState === WebSocket.OPEN) {
                    gyroWS.ws.addEventListener('message', messageHandler);
                } else {
                    // å¦‚æœ WebSocket æœªé€£æ¥ï¼Œç­‰å¾…é€£æ¥å¾Œå†æ·»åŠ ç›£è½å™¨
                    waitForWebSocketReady().then(() => {
                        gyroWS.ws.addEventListener('message', messageHandler);
                    }).catch(() => {
                        clearTimeout(timeout);
                        resolve(); // è¶…æ™‚æ™‚ä»ç„¶ resolve
                    });
                }
            });
        }
        
        // è¢å¹•æ•ç²åŠŸèƒ½
        let isStartingCapture = false; // é˜²æ­¢é‡è¤‡é»æ“Š
        
        async function startScreenCapture() {
            if (isStartingCapture) {
                console.log('âš ï¸ è¢å¹•æ•ç²æ­£åœ¨å•Ÿå‹•ä¸­ï¼Œè«‹ç¨å€™...');
                return;
            }
            
            try {
                isStartingCapture = true;
                console.log('ğŸ¬ é–‹å§‹è¢å¹•æ•ç²...');
                
                // æª¢æŸ¥ WebRTC æ”¯æ´
                if (!window.RTCPeerConnection) {
                    console.warn('âš ï¸ ä¸æ”¯æ´ WebRTCï¼Œä½¿ç”¨ WebSocket');
                    startWebSocketScreenCapture();
                    return;
                }
                
                // ç­‰å¾… WebSocket é€£æ¥å°±ç·’
                await waitForWebSocketReady();
                
                // ç”Ÿæˆæˆ¿é–“ ID
                const roomId = 'default-room';
                
                // åŠ å…¥æˆ¿é–“
                gyroWS.joinRoom(roomId, 'web-sender');
                
                // ç­‰å¾…æˆ¿é–“é…å°å®Œæˆ
                await waitForRoomReady();
                
                console.log('ğŸ¤ æˆ¿é–“é…å°å®Œæˆï¼Œé–‹å§‹ WebRTC');
                
                // ç¾åœ¨æ‰é–‹å§‹ WebRTC
                webrtcCapture = new WebRTCScreenCapture(gyroWS.ws, roomId);
                gyroWS.webrtcCapture = webrtcCapture;
                
                await webrtcCapture.start();
                
                // æ›´æ–° UI
                document.getElementById('startScreenCapture').style.display = 'none';
                document.getElementById('stopScreenCapture').style.display = 'inline-block';
                document.getElementById('screenCapturePreview').style.display = 'block';
                document.getElementById('captureStatus').textContent = 'WebRTC ä¸²æµä¸­';
                
            } catch (error) {
                console.error('âŒ è¢å¹•æ•æ‰å•Ÿå‹•å¤±æ•—:', error);
                startWebSocketScreenCapture();
            } finally {
                isStartingCapture = false;
            }
        }
        
        function startWebSocketScreenCapture() {
            console.log('ğŸ”„ åˆ‡æ›åˆ° WebSocket æ¨¡å¼');
            
            // åœæ­¢ WebRTCï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if (webrtcCapture) {
                webrtcCapture.teardown(false);
                webrtcCapture = null;
            }
            
            isUsingWebSocket = true;
            
            // ä½¿ç”¨ç¾æœ‰çš„ WebSocket è¢å¹•æ•æ‰é‚è¼¯
            startWebSocketScreenCaptureImpl();
        }
        
        async function startWebSocketScreenCaptureImpl() {
            try {
                console.log('ğŸ¬ é–‹å§‹ WebSocket è¢å¹•æ•ç²...');
                
                // è«‹æ±‚è¢å¹•æ•ç²æ¬Šé™
                screenCaptureStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        mediaSource: 'screen',
                        width: { ideal: 1280, max: 1920 },
                        height: { ideal: 720, max: 1080 },
                        frameRate: { ideal: 15, max: 30 }
                    },
                    audio: false
                });
                
                console.log('âœ… è¢å¹•æ•ç²æ¬Šé™å·²ç²å¾—');
                console.log('ğŸ“º æ•ç²çš„ç•«é¢ç¯„åœ:', screenCaptureStream.getVideoTracks()[0].label);
                
                // é¡¯ç¤ºæœ¬åœ°é è¦½
                const video = document.getElementById('screenCaptureVideo');
                video.srcObject = screenCaptureStream;
                await video.play();
                
                // å‰µå»ºCanvasç”¨æ–¼æ•ç²å¹€
                screenCaptureCanvas = document.createElement('canvas');
                screenCaptureCanvas.width = 1280;
                screenCaptureCanvas.height = 720;
                screenCaptureCtx = screenCaptureCanvas.getContext('2d');
                
                // é–‹å§‹æ•ç²å¹€
                isScreenCapturing = true;
                captureScreenFrames();
                
                // æ›´æ–°UI
                document.getElementById('startScreenCapture').style.display = 'none';
                document.getElementById('stopScreenCapture').style.display = 'inline-block';
                document.getElementById('screenCapturePreview').style.display = 'block';
                document.getElementById('captureStatus').textContent = 'WebSocket ä¸²æµä¸­';
                
                // æ›´æ–° Stats UI
                updateWebSocketStatsUI('WebSocket ä¸­ç¹¼', 'connected', 0, 0, 0, 'unknown');
                
                console.log('ğŸ“¹ WebSocket è¢å¹•æ•ç²å·²é–‹å§‹');
                
            } catch (error) {
                console.error('âŒ WebSocket è¢å¹•æ•ç²å¤±æ•—:', error);
                
                let errorMessage = 'è¢å¹•æ•ç²å¤±æ•—: ';
                if (error.name === 'NotAllowedError') {
                    errorMessage += 'ç”¨æˆ¶æ‹’çµ•äº†è¢å¹•æ•ç²æ¬Šé™';
                } else if (error.name === 'NotFoundError') {
                    errorMessage += 'æ‰¾ä¸åˆ°å¯ç”¨çš„è¢å¹•æ•ç²æº';
                } else {
                    errorMessage += error.message;
                }
                
                alert(errorMessage);
            }
        }
        
        function stopScreenCapture() {
            isScreenCapturing = false;
            
            if (screenCaptureStream) {
                screenCaptureStream.getTracks().forEach(track => track.stop());
                screenCaptureStream = null;
            }
            
            const video = document.getElementById('screenCaptureVideo');
            video.srcObject = null;
            
            // æ›´æ–°UI
            document.getElementById('startScreenCapture').style.display = 'inline-block';
            document.getElementById('stopScreenCapture').style.display = 'none';
            document.getElementById('screenCapturePreview').style.display = 'none';
            document.getElementById('captureStatus').textContent = 'æœªé–‹å§‹';
            
            console.log('ğŸ“¹ è¢å¹•æ•ç²å·²åœæ­¢');
        }
        
        function captureScreenFrames() {
            if (!isScreenCapturing) return;
            
            const video = document.getElementById('screenCaptureVideo');
            
            // ç¹ªè£½ç•¶å‰å¹€åˆ°Canvas
            screenCaptureCtx.drawImage(video, 0, 0, screenCaptureCanvas.width, screenCaptureCanvas.height);
            
            // è½‰æ›ç‚ºJPEGä¸¦ç™¼é€
            screenCaptureCanvas.toBlob((blob) => {
                if (blob && gyroWS.isConnected) {
                    blob.arrayBuffer().then(buffer => {
                        const imageData = new Uint8Array(buffer);
                        gyroWS.sendScreenCaptureData(imageData, buffer.byteLength);
                        
                        // æ›´æ–°çµ±è¨ˆæ•¸æ“š
                        screenCaptureTotalDataSize += buffer.byteLength;
                        screenCaptureFrameCount++;
                        
                        // æ›´æ–° WebSocket Stats
                        updateWebSocketStats();
                    });
                }
            }, 'image/jpeg', 0.7); // 70%å“è³ªçš„JPEG
            
            // 15fps (æ¯66msä¸€å¹€)
            setTimeout(() => captureScreenFrames(), 66);
        }
        
        // æ›´æ–° WebSocket Stats UI
        function updateWebSocketStatsUI(mode, state, bitrate, fps, rtt, candidate) {
            document.getElementById('webrtc-mode').textContent = mode;
            document.getElementById('webrtc-state').textContent = state;
            document.getElementById('webrtc-bitrate').textContent = bitrate + ' kbps';
            document.getElementById('webrtc-fps').textContent = fps + ' fps';
            document.getElementById('webrtc-rtt').textContent = rtt + ' ms';
            document.getElementById('webrtc-candidate').textContent = candidate;
        }
        
        // æ›´æ–° WebSocket çµ±è¨ˆæ•¸æ“š
        function updateWebSocketStats() {
            const now = Date.now();
            const timeDiff = (now - screenCaptureLastTime) / 1000;
            
            if (timeDiff > 0) {
                const currentFPS = Math.round(screenCaptureFrameCount / timeDiff);
                const currentBitrate = Math.round((screenCaptureTotalDataSize * 8) / (timeDiff * 1000)); // kbps
                
                updateWebSocketStatsUI('WebSocket ä¸­ç¹¼', 'connected', currentBitrate, currentFPS, 0, 'unknown');
            }
        }
        
        // å®šæœŸæ›´æ–° WebSocket çµ±è¨ˆ
        setInterval(() => {
            if (isUsingWebSocket && isScreenCapturing) {
                updateWebSocketStats();
            }
        }, 2000);
        
        // æ›´æ–°è¢å¹•æ•ç²çµ±è¨ˆæ•¸æ“š
        function updateScreenCaptureStats() {
            const now = Date.now();
            const timeDiff = (now - screenCaptureLastTime) / 1000;
            
            if (timeDiff > 0) {
                const currentFPS = Math.round(screenCaptureFrameCount / timeDiff);
                document.getElementById('captureFPS').textContent = `${currentFPS} FPS`;
                
                // é‡ç½®è¨ˆæ•¸å™¨
                screenCaptureFrameCount = 0;
                screenCaptureLastTime = now;
            }
            
            // æ›´æ–°æ•¸æ“šå¤§å°é¡¯ç¤º
            const sizeInKB = Math.round(screenCaptureTotalDataSize / 1024);
            document.getElementById('captureDataSize').textContent = `${sizeInKB} KB`;
        }
        
        // æ·»åŠ è¢å¹•æ•ç²æŒ‰éˆ•äº‹ä»¶ç›£è½å™¨
        document.addEventListener('DOMContentLoaded', function() {
            const startBtn = document.getElementById('startScreenCapture');
            const stopBtn = document.getElementById('stopScreenCapture');
            
            if (startBtn) {
                startBtn.addEventListener('click', startScreenCapture);
            }
            if (stopBtn) {
                stopBtn.addEventListener('click', stopScreenCapture);
            }
            
            // é–‹å§‹çµ±è¨ˆæ›´æ–°
            setInterval(updateScreenCaptureStats, 1000);
        });
        
        // 8th Wall ä¸–ç•Œè¿½è¹¤å¯¦ä¾‹ï¼ˆå…¨å±€è®Šæ•¸ï¼‰
        let eighthWallTracker = null;
        
        // é é¢è¼‰å…¥æ™‚ï¼šå…ˆé€£ä¸Š WebSocketï¼Œå†æª¢æŸ¥/è«‹æ±‚æ„Ÿæ¸¬å™¨æ¬Šé™ï¼ˆæˆæ¬Šå¾Œæ‰é–‹å§‹é€è³‡æ–™ï¼‰
        window.addEventListener('load', function () {
            try {
                if (!gyroWS || !gyroWS.ws || gyroWS.ws.readyState !== WebSocket.OPEN) {
                    gyroWS.connect();
                }
            } catch (e) {
                console.error('åˆå§‹åŒ– WebSocket é€£ç·šæ™‚å‡ºéŒ¯:', e);
            }
            
            // åˆå§‹åŒ– 8th Wall ä¸–ç•Œè¿½è¹¤ï¼ˆè‡ªå‹•å•Ÿå‹•ï¼Œç„¡éœ€ç”¨æˆ¶é»æ“Šï¼‰
            try {
                eighthWallTracker = new EighthWallWorldTracker(gyroWS);
                // ç­‰å¾… WebSocket é€£æ¥å¾Œå†åˆå§‹åŒ– 8th Wall
                gyroWS.setOnConnectedCallback(() => {
                    setTimeout(() => {
                        eighthWallTracker.init();
                    }, 500); // å»¶é² 500ms ç¢ºä¿ WebSocket å®Œå…¨å°±ç·’
                });
            } catch (e) {
                console.error('åˆå§‹åŒ– 8th Wall è¿½è¹¤å™¨æ™‚å‡ºéŒ¯:', e);
            }
            
            checkSensorSupport();
        });
        
        // è™•ç†è¦–çª—å¤§å°æ”¹è®Š
        window.addEventListener('resize', function() {
            // é‡æ–°è¨ˆç®—åœ–è¡¨ä½ç½®
            const alpha = parseFloat(document.getElementById('alpha').textContent);
            const beta = parseFloat(document.getElementById('beta').textContent);
            const gamma = parseFloat(document.getElementById('gamma').textContent);
            
            if (!isNaN(alpha) && !isNaN(beta) && !isNaN(gamma)) {
                updateChart(alpha, beta, gamma);
            }
        });
        
        // ===== SpinTest æ—‹è½¬æ§åˆ¶åŠŸèƒ½ =====
        
        const SPIN_SNAP_SETTINGS = {
            DEFAULT: 120,
            SELECTED: 90,
            LOCK_THRESHOLD: 375,
            LOCK_WAIT_DURATION: 5000
        };
        const ANGLE_SEND_INTERVAL = 50;
        let displayedSpinAngle = 0;
        let lastAngleSendTime = 0;
        let lastSentDisplayedAngle = null;
        
        // åˆ›å»ºéŸ³æ•ˆå¯¹è±¡
        const spinSoundEffect = new Audio('se_door_hanekaeri.mp3');
        const rotateSound = new Audio('cada7.MP3'); // æ¯5åº¦è§¦å‘éœ‡åŠ¨éŸ³æ•ˆ
        
        // é¢„åŠ è½½éŸ³æ•ˆä»¥å‡å°‘å»¶è¿Ÿ
        rotateSound.preload = 'auto';
        rotateSound.load();
        
        // åˆå§‹åŒ–éŸ³æ•ˆ - é¢„å…ˆåŠ è½½åˆ°å†…å­˜ä»¥å‡å°‘å»¶è¿Ÿ
        rotateSound.addEventListener('loadeddata', function() {
            console.log('cada7éŸ³æ•ˆå·²åŠ è½½å®Œæˆ');
        });
        
        // é¢„æ’­æ”¾ä¸€å°æ®µæ¥é¢„çƒ­éŸ³æ•ˆï¼ˆå…ˆé™éŸ³æ’­æ”¾ï¼‰
        setTimeout(() => {
            rotateSound.volume = 0;
            rotateSound.play().then(() => {
                rotateSound.pause();
                rotateSound.currentTime = 0;
                rotateSound.volume = 1;
                console.log('éŸ³æ•ˆé¢„çƒ­å®Œæˆ');
            }).catch(() => {
                rotateSound.volume = 1;
            });
        }, 500);
        
        // åˆ›å»ºéœ‡åŠ¨å‡½æ•°
        function triggerSpinVibration(pattern = [100, 50, 100]) {
            console.log("å°è¯•è§¦å‘æ—‹è½¬éœ‡åŠ¨ï¼Œæ¨¡å¼:", pattern);
            
            if ("vibrate" in navigator) {
                try {
                    const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    console.log("æ£€æµ‹åˆ°ç§»åŠ¨è®¾å¤‡:", isMobile);
                    
                    if (isMobile) {
                        navigator.vibrate(pattern);
                        console.log("ç§»åŠ¨è®¾å¤‡éœ‡åŠ¨è§¦å‘:", pattern);
                    } else {
                        console.log("æ¡Œé¢è®¾å¤‡ï¼Œéœ‡åŠ¨åŠŸèƒ½ä¸å¯ç”¨");
                    }
                } catch (error) {
                    console.log("éœ‡åŠ¨æ‰§è¡Œå¤±è´¥:", error);
                }
            } else {
                console.log("æ­¤è®¾å¤‡æˆ–æµè§ˆå™¨ä¸æ”¯æ´éœ‡åŠ¨åŠŸèƒ½");
            }
        }
        
        // === Android å°ˆç”¨ã€Œé½’è¼ªæ„Ÿã€éœ‡å‹•å‡½æ•¸ (å¼·åŒ–ç‰ˆ) ===
        let lastVibrationTime = 0;
        
        // æ¨¡å¼è¨­å®š
        const SMALL_VIBRATION = 40;  // å–®éœ‡ä¸€æ¬¡ï¼ˆ20ms æŒçºŒæ™‚é–“ï¼‰
        const BIG_VIBRATION = [200]; // å¤§éœ‡ - çµæŸå–®éœ‡ä¸€æ¬¡ï¼ˆ200msï¼‰
        
        function triggerVibration(pattern = SMALL_VIBRATION) {
            const now = Date.now();

            // ğŸ”¹ é¿å…éå¯†è§¸ç™¼ï¼šèˆ‡ä¸Šæ¬¡éœ‡å‹•é–“éš” <130ms å‰‡ç•¥é
            if (now - lastVibrationTime < 130) return;
            lastVibrationTime = now;

            // åƒ…é™ Android
            const isAndroid = /Android/i.test(navigator.userAgent);
            if (!isAndroid) return;

            // ğŸ”¹ ä½¿ç”¨ vibrate API
            if (navigator.vibrate) {
                try {
                    const result = navigator.vibrate(pattern);
                    console.log("ğŸ“³ Androidéœ‡å‹•è§¸ç™¼:", pattern, "result:", result);
                } catch (e) {
                    console.warn("éœ‡å‹•åŸ·è¡ŒéŒ¯èª¤:", e);
                }
            }
        }
        
        // === å¼ºåˆ¶è§¦å‘å¤§éœ‡åŠ¨ï¼ˆä¸å—èŠ‚æµé™åˆ¶ï¼‰===
        function triggerBigVibrationForce() {
            const isAndroid = /Android/i.test(navigator.userAgent);
            if (!isAndroid) return;
            
            if (navigator.vibrate) {
                try {
                    // å…ˆä¸­æ–­ä¹‹å‰çš„éœ‡åŠ¨
                    navigator.vibrate(0);
                    
                    // ç¨å¾®å»¶è¿Ÿåè§¦å‘å¤§éœ‡åŠ¨ï¼Œç¡®ä¿ä¸­æ–­ç”Ÿæ•ˆ
                    setTimeout(() => {
                        const result = navigator.vibrate(BIG_VIBRATION);
                        console.log("ğŸ’¥ å¼ºåˆ¶å¤§éœ‡åŠ¨è§¦å‘:", BIG_VIBRATION, "result:", result);
                        lastVibrationTime = Date.now(); // æ›´æ–°èŠ‚æµæ—¶é—´ï¼Œé¿å…åç»­å°éœ‡åŠ¨ç«‹å³è§¦å‘
                    }, 30); // 30mså»¶è¿Ÿç¡®ä¿ä¸­æ–­å®Œæˆ
                } catch (e) {
                    console.warn("å¼ºåˆ¶å¤§éœ‡åŠ¨æ‰§è¡Œé”™è¯¯:", e);
                }
            }
        }
        
        // åˆå§‹åŒ–æ—‹è½¬æ§åˆ¶å™¨
        function initializeSpinController() {
            // ç¡®ä¿ DOM å®Œå…¨è½½å…¥åå†åˆå§‹åŒ–
            $(document).ready(function() {
                console.log("DOM å·²è½½å…¥ï¼Œå¼€å§‹åˆå§‹åŒ–æ—‹è½¬æ§åˆ¶å™¨...");
                
                // æ£€æŸ¥å¿…è¦çš„åº“æ˜¯å¦å·²è½½å…¥
                if (typeof gsap === 'undefined') {
                    console.error("GSAP æœªè½½å…¥ï¼");
                    return;
                }
                
                if (typeof Draggable === 'undefined') {
                    console.error("Draggable æ’ä»¶æœªè½½å…¥ï¼");
                    return;
                }
                
                // æ£€æŸ¥æ—‹é’®å…ƒç´ æ˜¯å¦å­˜åœ¨
                const knobElement = document.getElementById("spinKnob");
                if (!knobElement) {
                    console.error("æ‰¾ä¸åˆ° #spinKnob å…ƒç´ ï¼");
                    return;
                }
                
                console.log("å¼€å§‹åˆ›å»ºæ—‹è½¬æ§åˆ¶å™¨...");
                
                const selectModeButton = document.getElementById("selectThisButton");
                const spinModeStatusEl = document.getElementById("spinModeStatus");
                
                // è¿½è¸ªå·²æ’­æ”¾çš„è§’åº¦åŒºé—´ï¼ˆä½¿ç”¨ç´¯ç§¯è§’åº¦æ–¹æ¡ˆï¼Œæ”¯æŒå¤šåœˆæ—‹è½¬ï¼‰
                let prevAngle = 0;  // ä¸Šä¸€å¸§è§’åº¦
                let accumulatedDelta = 0;  // ç´¯ç§¯è§’åº¦å·®
                let lastTriggerStep = 0;  // ä¸Šæ¬¡è§¦å‘çš„æ­¥æ•°
                const ROTATE_THRESHOLD = 15; // æ¯15åº¦è§¦å‘ä¸€æ¬¡éœ‡åŠ¨
                let isDragging = false; // è¿½è¸ªæ˜¯å¦æ­£åœ¨æ‹–æ‹½
                
                // æ—‹è½¬è§’åº¦è¿½è¸ªç›¸å…³å˜é‡
                let initialRotationAngle = null; // åˆå§‹è§’åº¦ï¼ˆç¬¬ä¸€æ¬¡æ‹–æ‹½æ—¶çš„è§’åº¦ï¼‰
                let totalAbsoluteRotation = 0; // ä»åˆå§‹ä½ç½®å¼€å§‹çš„æ€»ç»å¯¹æ—‹è½¬è§’åº¦ï¼ˆç”¨äºæ—¥å¿—æ˜¾ç¤ºï¼‰
                
                // æ¨¡å¼æ§åˆ¶ç›¸é—œè®Šæ•¸
                let currentSnapAngle = SPIN_SNAP_SETTINGS.DEFAULT;
                let isIn90Mode = false;
                let spinLocked = false;
                let snapResetTimer = null;
                let rotationAccumulatedForMode = 0;
                let lastModeAngleForThreshold = null;
                let spinDraggable = null;
                const SPIN_MODE_CONFIG = {
                    default: { label: '120Â° å¸é™„', snapAngle: SPIN_SNAP_SETTINGS.DEFAULT },
                    selected: { label: '90Â° å¸é™„', snapAngle: SPIN_SNAP_SETTINGS.SELECTED }
                };
                
                // ä¿®æ­£è§’åº¦å·®ï¼ˆå¤„ç†360åº¦è·³è½¬ï¼‰
                function normalizeAngleDelta(current, prev) {
                    let delta = current - prev;
                    // å¤„ç†è·¨360åº¦è¾¹ç•Œ
                    if (delta > 180) delta -= 360;
                    if (delta < -180) delta += 360;
                    return delta;
                }
                
                function showSelectButton(shouldShow) {
                    if (selectModeButton) {
                        selectModeButton.style.display = shouldShow ? 'inline-block' : 'none';
                    }
                }
                
                function clearSnapResetTimer() {
                    if (snapResetTimer) {
                        clearTimeout(snapResetTimer);
                        snapResetTimer = null;
                    }
                }
                
                function updateSpinModeStatus(modeKey) {
                    console.log('ğŸ”„ updateSpinModeStatus è¢«èª¿ç”¨ï¼ŒmodeKey=', modeKey);
                    const config = SPIN_MODE_CONFIG[modeKey];
                    if (!config) {
                        console.warn('âš ï¸ æ‰¾ä¸åˆ°æ¨¡å¼é…ç½®:', modeKey);
                        return;
                    }
                    console.log('ğŸ“‹ æ¨¡å¼é…ç½®:', config);
                    if (spinModeStatusEl) {
                        spinModeStatusEl.textContent = `ç›®å‰æ¨¡å¼ï¼š${config.label}`;
                        console.log('âœ… å·²æ›´æ–°æ¨¡å¼ç‹€æ…‹é¡¯ç¤º:', spinModeStatusEl.textContent);
                    } else {
                        console.warn('âš ï¸ spinModeStatusEl ä¸å­˜åœ¨');
                    }
                    if (gyroWS) {
                        if (typeof gyroWS.updateSpinModeInfo === 'function') {
                            gyroWS.updateSpinModeInfo(modeKey, config.snapAngle, config.label);
                            console.log('âœ… å·²æ›´æ–°æœ¬åœ°æ¨¡å¼è³‡è¨Š');
                        } else {
                            console.warn('âš ï¸ gyroWS.updateSpinModeInfo ä¸å­˜åœ¨');
                        }
                        if (typeof gyroWS.sendSpinMode === 'function') {
                            console.log('ğŸ“¤ æº–å‚™ç™¼é€æ¨¡å¼åˆ° Unity:', { modeKey, snapAngle: config.snapAngle, label: config.label });
                            gyroWS.sendSpinMode(modeKey, config.snapAngle, config.label);
                        } else {
                            console.warn('âš ï¸ gyroWS.sendSpinMode ä¸å­˜åœ¨');
                        }
                    } else {
                        console.error('âŒ gyroWS ä¸å­˜åœ¨ï¼');
                    }
                }
                
                function switchToDefaultMode() {
                    clearSnapResetTimer();
                    currentSnapAngle = SPIN_SNAP_SETTINGS.DEFAULT;
                    isIn90Mode = false;
                    spinLocked = false;
                    rotationAccumulatedForMode = 0;
                    lastModeAngleForThreshold = null;
                    initialRotationAngle = null;
                    totalAbsoluteRotation = 0;
                    showSelectButton(true);
                    gsap.set(knobElement, { rotation: 0 });
                    updateSpinAngleDisplay(true);
                    if (spinDraggable) {
                        spinDraggable.enable();
                    }
                    updateSpinModeStatus('default');
                    
                    // ç«‹å³ç™¼é€ä¸€æ¬¡ spin æ¶ˆæ¯ï¼ˆè§’åº¦ç‚º0ï¼‰ï¼Œç¢ºä¿ Unity ç«‹å³æ”¶åˆ°æ¨¡å¼ä¿¡æ¯
                    if (gyroWS && typeof gyroWS.sendSpinEvent === 'function') {
                        console.log('ğŸ“¤ ç«‹å³ç™¼é€ spin æ¶ˆæ¯ä»¥åŒæ­¥æ¨¡å¼ä¿¡æ¯åˆ° Unityï¼ˆåˆ‡å›120Â°æ¨¡å¼ï¼‰');
                        gyroWS.sendSpinEvent(0, Date.now());
                    }
                }
                
                function switchTo90Mode() {
                    console.log('ğŸ”„ switchTo90Mode è¢«èª¿ç”¨');
                    if (spinLocked || isIn90Mode) {
                        console.log('âš ï¸ ç„¡æ³•åˆ‡æ›ï¼šspinLocked=', spinLocked, 'isIn90Mode=', isIn90Mode);
                        return;
                    }
                    console.log('âœ… é–‹å§‹åˆ‡æ›åˆ°90Â°æ¨¡å¼');
                    clearSnapResetTimer();
                    isIn90Mode = true;
                    currentSnapAngle = SPIN_SNAP_SETTINGS.SELECTED;
                    console.log('âœ… å·²æ›´æ–°ï¼šisIn90Mode=', isIn90Mode, 'currentSnapAngle=', currentSnapAngle);
                    rotationAccumulatedForMode = 0;
                    lastModeAngleForThreshold = null;
                    initialRotationAngle = null;
                    totalAbsoluteRotation = 0;
                    gsap.set(knobElement, { rotation: 0 });
                    updateSpinAngleDisplay(true);
                    showSelectButton(false);
                    if (spinDraggable) {
                        spinDraggable.enable();
                    }
                    updateSpinModeStatus('selected');
                    
                    // ç«‹å³ç™¼é€ä¸€æ¬¡ spin æ¶ˆæ¯ï¼ˆè§’åº¦ç‚º0ï¼‰ï¼Œç¢ºä¿ Unity ç«‹å³æ”¶åˆ°æ¨¡å¼ä¿¡æ¯
                    if (gyroWS && typeof gyroWS.sendSpinEvent === 'function') {
                        console.log('ğŸ“¤ ç«‹å³ç™¼é€ spin æ¶ˆæ¯ä»¥åŒæ­¥æ¨¡å¼ä¿¡æ¯åˆ° Unity');
                        gyroWS.sendSpinEvent(0, Date.now());
                    }
                    
                    console.log('âœ… 90Â°æ¨¡å¼åˆ‡æ›å®Œæˆ');
                }
                
                function enforceFullRotationLock() {
                    if (spinLocked) return;
                    spinLocked = true;
                    rotationAccumulatedForMode = 0;
                    lastModeAngleForThreshold = null;
                    clearSnapResetTimer();
                    
                    try {
                        if (spinDraggable) {
                            spinDraggable.disable();
                        }
                    } catch (error) {
                        console.warn('åœç”¨æ—‹é’®æ‹–æ‹½å¤±è´¥:', error);
                    }
                    
                    gsap.to(knobElement, {
                        rotation: 360,
                        duration: 0.4,
                        ease: "power2.out",
                        onUpdate: updateSpinAngleDisplay,
                        onComplete: () => {
                            updateSpinAngleDisplay(true);
                            // æ¸…ç©ºç‚º0åº¦
                            gsap.set(knobElement, { rotation: 0 });
                            updateSpinAngleDisplay(true);
                        }
                    });
                    
                    spinSoundEffect.currentTime = 0;
                    spinSoundEffect.play().catch(e => console.log("éŸ³æ•ˆæ’­æ”¾å¤±è´¥:", e));
                    triggerBigVibrationForce();
                    
                    snapResetTimer = setTimeout(() => {
                        switchToDefaultMode();
                    }, SPIN_SNAP_SETTINGS.LOCK_WAIT_DURATION);
                }
                
                // è®¡ç®—ä»åˆå§‹è§’åº¦å¼€å§‹çš„æ€»æ—‹è½¬è§’åº¦ï¼ˆæ”¯æŒå¤šåœˆæ—‹è½¬ï¼‰
                function calculateTotalRotation(currentAngle) {
                    if (initialRotationAngle === null) return 0;
                    // ç›´æ¥è®¡ç®—å·®å€¼ï¼Œä¸ä½¿ç”¨normalizeAngleDeltaï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦çœŸå®çš„ç´¯ç§¯è§’åº¦
                    let delta = currentAngle - initialRotationAngle;
                    // è¿”å›ç»å¯¹æ—‹è½¬è§’åº¦
                    return Math.abs(delta);
                }
                
                // åˆ›å»ºå¯æ‹–æ‹½çš„æ—‹é’®
                const draggable = Draggable.create("#spinKnob", {
                    type: "rotation",
                    inertia: true,
                    onDragStart: function() {
                        if (spinLocked) {
                            this.endDrag();
                            return;
                        }
                        
                        // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æ‹–æ‹½ï¼Œè®°å½•åˆå§‹è§’åº¦
                        if (initialRotationAngle === null) {
                            initialRotationAngle = this.rotation;
                            totalAbsoluteRotation = 0;
                            console.log("åˆå§‹åŒ–æ—‹è½¬è§’åº¦:", initialRotationAngle);
                        }
                        
                        // è®°å½•å¼€å§‹æ‹–æ‹½æ—¶çš„è§’åº¦
                        this.startAngle = this.rotation;
                        prevAngle = this.rotation;  // åˆå§‹åŒ–ä¸Šä¸€å¸§è§’åº¦
                        accumulatedDelta = 0;  // é‡ç½®ç´¯ç§¯è§’åº¦
                        lastTriggerStep = 0;  // é‡ç½®è§¦å‘æ­¥æ•°
                        isDragging = true; // æ ‡è®°å¼€å§‹æ‹–æ‹½
                        lastModeAngleForThreshold = isIn90Mode ? this.rotation : null;
                        
                        // å¼€å§‹æ’­æ”¾éŸ³æ•ˆ - ç«‹å³æ’­æ”¾ï¼Œä¸ç­‰å¾…
                        try {
                            rotateSound.loop = true; // è®¾ç½®å¾ªç¯æ’­æ”¾
                            const playPromise = rotateSound.play();
                            
                            // å¦‚æœæµè§ˆå™¨éœ€è¦ç”¨æˆ·äº¤äº’
                            if (playPromise !== undefined) {
                                playPromise.catch(error => {
                                    // å¦‚æœè‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼Œå°è¯•ç«‹å³æ’­æ”¾
                                    console.log("è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼Œå°è¯•ç«‹å³æ’­æ”¾:", error);
                                    rotateSound.play();
                                });
                            }
                        } catch(e) {
                            console.log("éŸ³æ•ˆæ’­æ”¾å¤±è´¥:", e);
                            // å¤±è´¥æ—¶ä¹Ÿå°è¯•æ’­æ”¾
                            rotateSound.play();
                        }
                        
                        console.log("å¼€å§‹æ‹–æ‹½ï¼Œå¼€å§‹æ’­æ”¾éŸ³æ•ˆã€‚èµ·å§‹è§’åº¦:", this.startAngle);
                    },
                    onDrag: function() {
                        if (spinLocked) {
                            return;
                        }
                        
                        let currentAngle = this.rotation;
                        
                        // æ›´æ–°æ€»æ—‹è½¬è§’åº¦ï¼ˆç”¨äºæ—¥å¿—æ˜¾ç¤ºï¼‰
                        if (initialRotationAngle !== null) {
                            totalAbsoluteRotation = calculateTotalRotation(currentAngle);
                        }
                        
                        let rotationDelta = currentAngle - this.startAngle;
                        
                        // è®¡ç®—è·¨å¸§è§’åº¦å·®ï¼ˆå¤„ç†360åº¦è¾¹ç•Œï¼‰
                        let frameDelta = normalizeAngleDelta(currentAngle, prevAngle);
                        accumulatedDelta += frameDelta;
                        prevAngle = currentAngle;
                        
                        // è®¡ç®—å½“å‰ç´¯ç§¯æ­¥æ•°
                        let currentStep = Math.floor(accumulatedDelta / ROTATE_THRESHOLD);
                        
                        // å¦‚æœç´¯ç§¯æ­¥æ•°å¢åŠ ï¼Œè§¦å‘éœ‡åŠ¨
                        if (currentStep !== lastTriggerStep) {
                            triggerVibration(SMALL_VIBRATION);
                            lastTriggerStep = currentStep;
                            console.log(`é½¿è½®éœ‡åŠ¨è§¦å‘ï¼š${currentAngle.toFixed(1)}Â°ï¼Œç´¯ç§¯æ—‹è½¬: ${accumulatedDelta.toFixed(1)}Â°ï¼Œæ­¥æ•°: ${currentStep}ï¼Œæ€»æ—‹è½¬: ${totalAbsoluteRotation.toFixed(1)}Â°`);
                        }
                        
                        // å®æ—¶æ›´æ–°è§’åº¦æ˜¾ç¤º
                        updateSpinAngleDisplay();
                        
                        // 90åº¦æ¨¡å¼ä¸‹çš„ç¸½æ—‹è½‰ç´¯ç©æª¢æŸ¥
                        if (isIn90Mode && !spinLocked) {
                            if (lastModeAngleForThreshold === null) {
                                lastModeAngleForThreshold = currentAngle;
                            } else {
                                rotationAccumulatedForMode += Math.abs(normalizeAngleDelta(currentAngle, lastModeAngleForThreshold));
                                lastModeAngleForThreshold = currentAngle;
                                
                                if (rotationAccumulatedForMode >= SPIN_SNAP_SETTINGS.LOCK_THRESHOLD) {
                                    enforceFullRotationLock();
                                    return;
                                }
                            }
                        }
                        
                        // é™åˆ¶æ—‹è½¬å¢é‡åœ¨ 90 åº¦ä»¥å†…
                        const snapHalfRange = currentSnapAngle / 2;
                        if (Math.abs(rotationDelta) > snapHalfRange) {
                            // è®¡ç®—å¸é™„å¢é‡åçš„ç›®æ ‡è§’åº¦
                            let proposedTargetAngle = this.startAngle + (rotationDelta > 0 ? currentSnapAngle : -currentSnapAngle);
                            
                            // å¼ºåˆ¶è®¾å®šåˆ°é™åˆ¶çš„è§’åº¦ï¼Œä½¿ç”¨å›å¼¹åŠ¨ç”»
                            gsap.to(this.target, {
                                rotation: proposedTargetAngle,
                                duration: 0.4,
                                ease: "elastic.out(1, 0.4)",
                                onUpdate: updateSpinAngleDisplay,
                                onComplete: () => updateSpinAngleDisplay(true)
                            });
                            
                            // æ³¨æ„ï¼š90åº¦é™åˆ¶æ—¶ä¸æ’­æ”¾éŸ³æ•ˆï¼Œåªåœ¨æ¾å¼€æ‰‹æ—¶æ’­æ”¾
                            
                            // æ³¨æ„ï¼šä¸åœ¨è¿™é‡Œå‘é€è§’åº¦ï¼Œå› ä¸ºå®æ—¶å‘é€ï¼ˆä¸Šæ–¹ï¼‰å·²ç»æŒç»­å‘é€çœŸå®è§’åº¦
                            // é™åˆ¶é€»è¾‘åªå½±å“ç½‘é¡µç«¯çš„è§†è§‰å›å¼¹æ•ˆæœï¼ŒUnityæ¥æ”¶çš„åº”è¯¥æ˜¯çœŸå®çš„ç´¯ç§¯è§’åº¦
                            
                            // æ³¨æ„ï¼š90åº¦é™åˆ¶æ—¶ä¸è§¦å‘å¤§éœ‡åŠ¨ï¼Œåªåœ¨æ¾å¼€æ‰‹æ—¶è§¦å‘
                            
                            // ğŸ”§ å…³é”®ä¿®å¤ï¼šæ›´æ–° startAngle ä¸ºé™åˆ¶åçš„è§’åº¦
                            // è¿™æ ·ä¸‹ä¸€è½®çš„90åº¦é™åˆ¶ä¼šåŸºäºæ–°çš„åŸºå‡†è§’åº¦ï¼Œä¿æŒè§’åº¦ç´¯ç§¯çš„æ­£ç¡®æ€§
                            this.startAngle = proposedTargetAngle;
                            
                            // é‡ç½®ç´¯ç§¯è§’åº¦åŸºå‡†ï¼ˆç”¨äºéœ‡åŠ¨æ£€æµ‹ï¼‰
                            accumulatedDelta = 0;
                            lastTriggerStep = 0;
                            
                            // âš ï¸ é‡è¦ï¼šä¸è¦é‡ç½® prevAngleï¼Œä¿æŒä½¿ç”¨å½“å‰çš„ actualAngle
                            // å¦åˆ™ä¼šå¯¼è‡´è§’åº¦è®¡ç®—å‡ºç°è·³è·ƒï¼Œè®©æ•°å€¼ä»å‡ åƒåº¦çªç„¶å˜æˆå‡ ç™¾åº¦
                            
                            // æ›´æ–°æ€»æ—‹è½¬è§’åº¦ç”¨äºæ—¥å¿—
                            if (initialRotationAngle !== null) {
                                totalAbsoluteRotation = calculateTotalRotation(proposedTargetAngle);
                            }
                            
                            console.log(`æ—‹è½¬è¢«é™åˆ¶åˆ°: ${proposedTargetAngle}Â° (å¢é‡: ${rotationDelta.toFixed(1)}Â°)ï¼Œå·²æ›´æ–°åŸºå‡†è§’åº¦ï¼Œæ€»æ—‹è½¬: ${totalAbsoluteRotation.toFixed(1)}Â°`);
                        } else {
                            console.log("æ‹–æ‹½ä¸­ï¼Œæ—‹è½¬è§’åº¦:", this.rotation, "å¢é‡:", rotationDelta.toFixed(1), "æ€»æ—‹è½¬:", totalAbsoluteRotation.toFixed(1) + "Â°");
                        }
                    },
                    onDragEnd: function() {
                        if (spinLocked) {
                            rotateSound.pause();
                            rotateSound.currentTime = 0;
                            rotateSound.loop = false;
                            return;
                        }
                        
                        // æ ‡è®°æ‹–æ‹½ç»“æŸ
                        isDragging = false;
                        
                        // åœæ­¢æ’­æ”¾éŸ³æ•ˆ
                        rotateSound.pause();
                        rotateSound.currentTime = 0;
                        rotateSound.loop = false; // å–æ¶ˆå¾ªç¯
                        console.log("æ‹–æ‹½ç»“æŸï¼ŒéŸ³æ•ˆå·²åœæ­¢");
                        
                        // æ‹–æ‹½ç»“æŸæ—¶è¿›è¡Œæœ€ç»ˆå¸é™„
                        let currentAngle = this.rotation;
                        
                        // æ›´æ–°æ€»æ—‹è½¬è§’åº¦ï¼ˆç”¨äºæ—¥å¿—æ˜¾ç¤ºï¼‰
                        if (initialRotationAngle !== null) {
                            totalAbsoluteRotation = calculateTotalRotation(currentAngle);
                        }
                        
                        let rotationDelta = currentAngle - this.startAngle;
                        
                        // è®¡ç®—æœ€ç»ˆè§’åº¦ï¼ˆé™åˆ¶åœ¨å½“å‰å¸é™„è§’åº¦å¢é‡å†…ï¼‰
                        let finalAngle = this.startAngle;
                        const snapRange = currentSnapAngle / 2;
                        if (Math.abs(rotationDelta) > snapRange) {
                            finalAngle = this.startAngle + (rotationDelta > 0 ? currentSnapAngle : -currentSnapAngle);
                        } else {
                            // å¦‚æœå¢é‡å°äº 45 åº¦ï¼Œå›åˆ°èµ·å§‹è§’åº¦
                            finalAngle = this.startAngle;
                        }
                        
                        // ä½¿ç”¨å¼ºçƒˆçš„å›å¼¹åŠ¨ç”»å¸é™„åˆ°æœ€ç»ˆè§’åº¦
                        gsap.to(this.target, {
                            rotation: finalAngle,
                            duration: 0.6,
                            ease: "elastic.out(1, 0.3)",
                            onUpdate: updateSpinAngleDisplay,
                            onComplete: () => updateSpinAngleDisplay(true)
                        });

                        // æ£€æŸ¥æ€»æ—‹è½¬è§’åº¦ï¼ˆä»å¼€å§‹åˆ°ç»“æŸï¼‰
                        const totalRotation = Math.abs(rotationDelta);
                        
                        // ğŸ”§ ä¿®å¤ï¼šæ— è®ºæ—‹è½¬å¤šå°‘åº¦ï¼Œæ¾å¼€æ‰‹å°±è§¦å‘å¤§éœ‡åŠ¨å’ŒéŸ³æ•ˆ
                        spinSoundEffect.currentTime = 0; // é‡ç½®éŸ³æ•ˆ
                        spinSoundEffect.play().catch(e => console.log("éŸ³æ•ˆæ’­æ”¾å¤±è´¥:", e));
                        triggerBigVibrationForce(); // å¼ºåˆ¶è§¦å‘å¤§éœ‡åŠ¨ï¼Œä¸å—èŠ‚æµé™åˆ¶
                        
                        // å‘é€å½“å‰å®é™…è§’åº¦åˆ°Unityï¼ˆä¸æ˜¯å¸é™„åçš„è§’åº¦ï¼Œè€Œæ˜¯çœŸå®çš„ç´¯ç§¯è§’åº¦ï¼‰
                    console.log('ğŸ¯ å‡†å¤‡å‘é€æ—‹è½¬äº‹ä»¶ï¼ˆonDragEndï¼‰ï¼Œæ˜¾ç¤ºè§’åº¦:', displayedSpinAngle, "æ€»æ—‹è½¬:", totalAbsoluteRotation.toFixed(1) + "Â°");

                        console.log(`æ‹–æ‹½ç»“æŸï¼Œæœ€ç»ˆè§’åº¦: ${finalAngle}Â° (å¢é‡: ${rotationDelta.toFixed(1)}Â°)`);
                        
                        // æ›´æ–°æœ€ç»ˆè§’åº¦æ˜¾ç¤º
                        updateSpinAngleDisplay();
                    }
                });
                
                spinDraggable = draggable[0];
                
                if (selectModeButton) {
                    selectModeButton.addEventListener('click', switchTo90Mode);
                }
                
                switchToDefaultMode();
                console.log("æ—‹è½¬æ§åˆ¶å™¨åˆ›å»ºæˆåŠŸ:", draggable);
                
                // åˆå§‹åŒ–è§’åº¦æ˜¾ç¤º
                updateSpinAngleDisplay();
                
                console.log("æ—‹è½¬æ§åˆ¶å™¨åˆå§‹åŒ–å®Œæˆï¼");
            });
        }
        
        // æ›´æ–°è§’åº¦æ˜¾ç¤ºçš„å‡½æ•¸
        function syncDisplayedAngleWithUnity(force = false) {
            if (!gyroWS || typeof gyroWS.sendSpinEvent !== 'function') return;
            const now = Date.now();
            if (!force && (now - lastAngleSendTime < ANGLE_SEND_INTERVAL) && lastSentDisplayedAngle === displayedSpinAngle) {
                return;
            }
            gyroWS.sendSpinEvent(displayedSpinAngle);
            lastAngleSendTime = now;
            lastSentDisplayedAngle = displayedSpinAngle;
        }
        
        function updateSpinAngleDisplay(force = false) {
            const currentRotation = gsap.getProperty("#spinKnob", "rotation");
            displayedSpinAngle = currentRotation;
            $("#spinAngleDisplay").text("å½“å‰è§’åº¦: " + currentRotation.toFixed(1) + "Â°");
            syncDisplayedAngleWithUnity(force);
        }
        
        // é¡µé¢è½½å…¥æ—¶åˆå§‹åŒ–æ—‹è½¬æ§åˆ¶å™¨
        window.addEventListener('load', function () {
            // å»¶è¿Ÿåˆå§‹åŒ–ï¼Œç¡®ä¿å…¶ä»–åº“å·²è½½å…¥
            setTimeout(() => {
                initializeSpinController();
            }, 1000);
        });
    </script>
</body>
</html>




