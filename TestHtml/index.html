<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手機陀螺儀偵測器 v2.0 - 搖晃偵測版</title>
    <!-- 引入 GSAP 核心库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <!-- 引入 GSAP Draggable 插件 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/Draggable.min.js"></script>
    <!-- 引入 jQuery 库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .status {
            text-align: center;
            margin-bottom: 30px;
            padding: 15px;
            border-radius: 10px;
            font-size: 1.2em;
            font-weight: bold;
        }
        
        .status.supported {
            background: rgba(76, 175, 80, 0.3);
            border: 2px solid #4CAF50;
        }
        
        .status.not-supported {
            background: rgba(244, 67, 54, 0.3);
            border: 2px solid #f44336;
        }
        
        .data-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .data-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .data-card h3 {
            margin: 0 0 15px 0;
            font-size: 1.3em;
            color: #FFD700;
        }
        
        .shake-detected {
            background: linear-gradient(45deg, #FF6B6B, #FF8E8E) !important;
            animation: shakePulse 0.5s ease-in-out;
        }
        
        @keyframes shakePulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        @keyframes shakePulseStrong {
            0% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.08) rotate(-1deg); }
            50% { transform: scale(1.12) rotate(1deg); }
            75% { transform: scale(1.08) rotate(-0.5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }
        
        @keyframes shakePulseIntense {
            0% { transform: scale(1) rotate(0deg); }
            20% { transform: scale(1.1) rotate(-2deg); }
            40% { transform: scale(1.15) rotate(2deg); }
            60% { transform: scale(1.1) rotate(-1deg); }
            80% { transform: scale(1.05) rotate(1deg); }
            100% { transform: scale(1) rotate(0deg); }
        }
        
        @keyframes shakeDemo {
            0% { transform: rotateX(0deg) rotateY(0deg); }
            25% { transform: rotateX(15deg) rotateY(15deg); }
            50% { transform: rotateX(-10deg) rotateY(-10deg); }
            75% { transform: rotateX(10deg) rotateY(-15deg); }
            100% { transform: rotateX(0deg) rotateY(0deg); }
        }
        
        .data-value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .unit {
            font-size: 0.8em;
            opacity: 0.8;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .chart {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .chart-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, #FF6B6B, #4ECDC4, #45B7D1);
            transition: all 0.1s ease;
        }
        
        .instructions {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid #FFD700;
        }
        
        .instructions h3 {
            margin-top: 0;
            color: #FFD700;
        }
        
        .instructions ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .instructions li {
            margin: 8px 0;
            line-height: 1.5;
        }
        
        .deploy-info {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid #4CAF50;
        }
        
        .deploy-info h3 {
            margin-top: 0;
            color: #4CAF50;
        }
        
        .url-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 1.1em;
            word-break: break-all;
        }

        /* 立方體功能區塊 */
        .cube-feature {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid #FF6B6B;
        }

        .cube-feature h3 {
            margin-top: 0;
            color: #FF6B6B;
            font-size: 1.5em;
            margin-bottom: 15px;
        }

        .cube-preview {
            display: flex;
            align-items: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .cube-mini {
            width: 80px;
            height: 80px;
            position: relative;
            transform-style: preserve-3d;
            animation: miniRotate 4s infinite linear;
        }

        .cube-mini .face {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        .cube-mini .face.front { background: linear-gradient(135deg, #FF6B6B, #FF8E8E); transform: translateZ(40px); }
        .cube-mini .face.back { background: linear-gradient(135deg, #4ECDC4, #7EDDDD); transform: translateZ(-40px) rotateY(180deg); }
        .cube-mini .face.right { background: linear-gradient(135deg, #45B7D1, #6BC5D8); transform: rotateY(90deg) translateZ(40px); }
        .cube-mini .face.left { background: linear-gradient(135deg, #96CEB4, #B8E6B8); transform: rotateY(-90deg) translateZ(40px); }
        .cube-mini .face.top { background: linear-gradient(135deg, #FFEAA7, #FFF2CC); transform: rotateX(90deg) translateZ(40px); }
        .cube-mini .face.bottom { background: linear-gradient(135deg, #DDA0DD, #E6B8E6); transform: rotateX(-90deg) translateZ(40px); }

        @keyframes miniRotate {
            from { transform: rotateX(0deg) rotateY(0deg); }
            to { transform: rotateX(360deg) rotateY(360deg); }
        }

        @keyframes screenCapture {
            0% { transform: rotateX(0deg) rotateY(0deg) scale(1); }
            25% { transform: rotateX(15deg) rotateY(15deg) scale(1.05); }
            50% { transform: rotateX(-10deg) rotateY(-10deg) scale(1.1); }
            75% { transform: rotateX(10deg) rotateY(-15deg) scale(1.05); }
            100% { transform: rotateX(0deg) rotateY(0deg) scale(1); }
        }

        .cube-info {
            flex: 1;
            min-width: 200px;
        }

        .cube-info h4 {
            color: #FFD700;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .cube-info p {
            margin: 8px 0;
            line-height: 1.5;
            opacity: 0.9;
        }

        .cube-link {
            display: inline-block;
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            text-decoration: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: bold;
            margin-top: 15px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .cube-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .feature-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .feature-item .icon {
            font-size: 2em;
            margin-bottom: 10px;
            display: block;
        }

        .feature-item h5 {
            color: #4ECDC4;
            margin-bottom: 8px;
        }

        .feature-item p {
            font-size: 0.9em;
            opacity: 0.8;
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .data-grid {
                grid-template-columns: 1fr;
            }
            
            .cube-preview {
                flex-direction: column;
                text-align: center;
            }
            
            .cube-mini {
                margin: 0 auto 20px auto;
            }
            
            .feature-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .cube-link {
                display: block;
                text-align: center;
                margin: 20px auto 0 auto;
                max-width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>📱 手機陀螺儀偵測器 v2.1</h1>
        <div style="text-align: center; margin-bottom: 20px; font-size: 1.2em; color: #FFD700;">
            🆕 搖晃偵測 + 螢幕捕獲 | 三軸感測器 | 即時數據傳輸
        </div>
        
        <div id="status" class="status">
            正在檢查陀螺儀支援...
        </div>
        
        <div class="data-grid">
            <div class="data-card">
                <h3>X 軸 (Alpha)</h3>
                <div id="alpha" class="data-value">0.00</div>
                <div class="unit">度 (0-360)</div>
            </div>
            
            <div class="data-card">
                <h3>Y 軸 (Beta)</h3>
                <div id="beta" class="data-value">0.00</div>
                <div class="unit">度 (-180 到 180)</div>
            </div>
            
            <div class="data-card">
                <h3>Z 軸 (Gamma)</h3>
                <div id="gamma" class="data-value">0.00</div>
                <div class="unit">度 (-90 到 90)</div>
            </div>
            
            <div class="data-card">
                <h3>搖晃偵測</h3>
                <div id="shake-status" class="data-value">靜止</div>
                <div class="unit">狀態</div>
            </div>
            
            <div class="data-card">
                <h3>搖晃次數</h3>
                <div id="shake-count" class="data-value">0</div>
                <div class="unit">次</div>
            </div>
            
            <div class="data-card">
                <h3>加速度強度</h3>
                <div id="acceleration-magnitude" class="data-value">0.00</div>
                <div class="unit">m/s²</div>
            </div>
            
            <div class="data-card">
                <h3>搖晃強度</h3>
                <div id="shake-intensity" class="data-value">靜止</div>
                <div class="unit">狀態</div>
            </div>
        </div>
        
        <div class="chart-container">
            <h3 style="text-align: center; margin-top: 0; color: #FFD700;">即時數據圖表</h3>
            <div class="chart" id="chart">
                <div class="chart-line" id="alpha-line" style="top: 33%; background: #FF6B6B;"></div>
                <div class="chart-line" id="beta-line" style="top: 50%; background: #4ECDC4;"></div>
                <div class="chart-line" id="gamma-line" style="top: 66%; background: #45B7D1;"></div>
            </div>
        </div>
        
        <div class="cube-feature">
            <h3>🆕 v2.0 新功能：智能搖晃偵測</h3>
            
            <div class="cube-preview">
                <div class="cube-mini" style="animation: shakeDemo 2s infinite ease-in-out;">
                    <div class="face front">搖</div>
                    <div class="face back">晃</div>
                    <div class="face right">偵</div>
                    <div class="face left">測</div>
                    <div class="face top">v2</div>
                    <div class="face bottom">.0</div>
                </div>
                
                <div class="cube-info">
                    <h4>🎯 精準搖晃偵測系統</h4>
                    <p><strong>基於加速度感測器的智能搖晃偵測</strong></p>
                    <p>• 使用標準演算法：加速度變化量 + 連續檢測</p>
                    <p>• 三級強度分類：一般搖晃、強烈搖晃、劇烈搖晃</p>
                    <p>• 防誤判機制：連續3次超標才觸發</p>
                    <p>• 即時視覺回饋：動畫效果 + 強度指示</p>
                </div>
            </div>
            
            <div class="feature-grid">
                <div class="feature-item">
                    <span class="icon">📊</span>
                    <h5>精準閾值</h5>
                    <p>10-15 m/s² 標準閾值</p>
                </div>
                <div class="feature-item">
                    <span class="icon">⚡</span>
                    <h5>即時響應</h5>
                    <p>毫秒級偵測延遲</p>
                </div>
                <div class="feature-item">
                    <span class="icon">🛡️</span>
                    <h5>防誤判</h5>
                    <p>連續檢測機制</p>
                </div>
                <div class="feature-item">
                    <span class="icon">🎨</span>
                    <h5>視覺回饋</h5>
                    <p>動畫 + 顏色指示</p>
                </div>
            </div>
        </div>
        
        <div class="cube-feature" style="border-left-color: #4ECDC4;">
            <h3>🎲 3D 陀螺儀立方體</h3>
            
            <div class="cube-preview">
                <div class="cube-mini">
                    <div class="face front">前</div>
                    <div class="face back">後</div>
                    <div class="face right">右</div>
                    <div class="face left">左</div>
                    <div class="face top">上</div>
                    <div class="face bottom">下</div>
                </div>
                
                <div class="cube-info">
                    <h4>體驗互動式3D立方體</h4>
                    <p>使用手機陀螺儀控制一個六面不同顏色的3D立方體</p>
                    <p>每個面都有獨特的漸層色彩和文字標識</p>
                    <p>即時響應手機的旋轉動作，創造沉浸式3D體驗</p>
                    <a href="gyroscope-cube.html" class="cube-link">🚀 立即體驗</a>
                </div>
            </div>
            
            <div class="feature-grid">
                <div class="feature-item">
                    <span class="icon">🎨</span>
                    <h5>六面彩色</h5>
                    <p>每個面都有獨特的漸層色彩</p>
                </div>
                <div class="feature-item">
                    <span class="icon">📱</span>
                    <h5>陀螺儀控制</h5>
                    <p>即時響應手機旋轉動作</p>
                </div>
                <div class="feature-item">
                    <span class="icon">🎯</span>
                    <h5>精準追蹤</h5>
                    <p>三軸旋轉數據即時更新</p>
                </div>
                <div class="feature-item">
                    <span class="icon">✨</span>
                    <h5>視覺效果</h5>
                    <p>3D透視和動畫效果</p>
                </div>
            </div>
        </div>
        
        <div class="cube-feature" style="border-left-color: #FF9800;">
            <h3>📺 螢幕捕獲串流</h3>
            
            <div class="cube-preview">
                <div class="cube-mini" style="animation: screenCapture 3s infinite ease-in-out;">
                    <div class="face front">螢</div>
                    <div class="face back">幕</div>
                    <div class="face right">捕</div>
                    <div class="face left">獲</div>
                    <div class="face top">📺</div>
                    <div class="face bottom">串流</div>
                </div>
                
                <div class="cube-info">
                    <h4>即時螢幕捕獲與串流</h4>
                    <p>捕獲整個螢幕或特定視窗，透過WebSocket即時傳送到Unity</p>
                    <p>支援全螢幕、特定視窗、瀏覽器標籤頁捕獲</p>
                    <p>WebRTC P2P 優先，WebSocket 降級備用</p>
                    <button id="startScreenCapture" class="cube-link" style="border: none; cursor: pointer;">🎬 開始捕獲</button>
                    <button id="stopScreenCapture" class="cube-link" style="border: none; cursor: pointer; background: linear-gradient(45deg, #f44336, #da190b); display: none;">⏹️ 停止捕獲</button>
                    
                    <div class="webrtc-stats" style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px; font-size: 0.9em;">
                        <h4 style="margin: 0 0 10px 0; color: #FFD700;">傳輸狀態</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                            <div>模式: <span id="transferMode">準備中</span></div>
                            <div>狀態: <span id="connectionState">未連接</span></div>
                            <div>位元率: <span id="webrtcBitrate">0 kbps</span></div>
                            <div>幀率: <span id="webrtcFPS">0 fps</span></div>
                            <div>RTT: <span id="webrtcRTT">0 ms</span></div>
                            <div>候選者: <span id="webrtcCandidate">unknown</span></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="feature-grid">
                <div class="feature-item">
                    <span class="icon">🖥️</span>
                    <h5>全螢幕捕獲</h5>
                    <p>捕獲整個桌面畫面</p>
                </div>
                <div class="feature-item">
                    <span class="icon">🪟</span>
                    <h5>視窗選擇</h5>
                    <p>選擇特定應用程式視窗</p>
                </div>
                <div class="feature-item">
                    <span class="icon">📱</span>
                    <h5>即時串流</h5>
                    <p>15fps流暢傳輸</p>
                </div>
                <div class="feature-item">
                    <span class="icon">🎯</span>
                    <h5>Unity整合</h5>
                    <p>直接傳送到Unity客戶端</p>
                </div>
            </div>
            
            <!-- 螢幕捕獲預覽 -->
            <div id="screenCapturePreview" style="display: none; margin-top: 20px;">
                <h4 style="color: #FFD700; margin-bottom: 15px;">📱 螢幕捕獲預覽</h4>
                <video id="screenCaptureVideo" autoplay muted style="width: 100%; max-width: 500px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);"></video>
                <div id="screenCaptureStats" style="margin-top: 15px; display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                    <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; text-align: center;">
                        <div style="color: #4ECDC4; font-weight: bold;">串流狀態</div>
                        <div id="captureStatus">未開始</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; text-align: center;">
                        <div style="color: #4ECDC4; font-weight: bold;">幀率</div>
                        <div id="captureFPS">0 FPS</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; text-align: center;">
                        <div style="color: #4ECDC4; font-weight: bold;">數據大小</div>
                        <div id="captureDataSize">0 KB</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="cube-feature" style="border-left-color: #9C27B0;">
            <h3>🎯 旋转控制器</h3>
            
            <div class="cube-preview">
                <div style="position: relative; width: 200px; height: 200px;">
                    <img id="spinKnob" src="https://i.postimg.cc/mr45tyXJ/Hi-Paint-1760323869267.png" 
                         style="width: 100%; height: 100%; cursor: grab;">
                </div>
                
                <div class="cube-info">
                    <h4>拖拽旋转控制</h4>
                    <p>拖拽旋钮超过45度触发90度旋转</p>
                    <p>触发时播放音效并震动反馈</p>
                    <div id="spinAngleDisplay" style="font-size: 1.2em; color: #FFD700; margin-top: 10px;">
                        当前角度: 0°
                    </div>
                </div>
            </div>
            
            <div class="feature-grid">
                <div class="feature-item">
                    <span class="icon">🎯</span>
                    <h5>精确控制</h5>
                    <p>45度触发，90度限制</p>
                </div>
                <div class="feature-item">
                    <span class="icon">🔊</span>
                    <h5>音效反馈</h5>
                    <p>触发时播放音效</p>
                </div>
                <div class="feature-item">
                    <span class="icon">📳</span>
                    <h5>震动反馈</h5>
                    <p>移动设备震动</p>
                </div>
                <div class="feature-item">
                    <span class="icon">📡</span>
                    <h5>Unity同步</h5>
                    <p>实时传输到Unity</p>
                </div>
            </div>
        </div>
        
        <div class="deploy-info">
            <h3>🚀 快速部署方案</h3>
            <p><strong>方案一：Netlify（推薦）</strong></p>
            <ol>
                <li>前往 <a href="https://netlify.com" target="_blank" style="color: #4CAF50;">netlify.com</a></li>
                <li>註冊/登入帳號</li>
                <li>將此資料夾拖拽到 "Deploy manually" 區域</li>
                <li>獲得 HTTPS 網址，例如：<span class="url-box">https://your-site-name.netlify.app</span></li>
            </ol>
            
            <p><strong>方案二：Vercel</strong></p>
            <ol>
                <li>前往 <a href="https://vercel.com" target="_blank" style="color: #4CAF50;">vercel.com</a></li>
                <li>註冊/登入帳號</li>
                <li>上傳此資料夾</li>
                <li>獲得 HTTPS 網址</li>
            </ol>
            
            <p><strong>方案三：GitHub Pages</strong></p>
            <ol>
                <li>建立 GitHub 儲存庫</li>
                <li>上傳檔案到儲存庫</li>
                <li>在設定中啟用 GitHub Pages</li>
                <li>獲得網址：<span class="url-box">https://your-username.github.io/your-repo-name</span></li>
            </ol>
        </div>
        
        <div class="instructions">
            <h3>📋 v2.0 使用說明</h3>
            <ul>
                <li><strong>基本操作：</strong>請在手機上開啟此網頁</li>
                <li><strong>權限設定：</strong>允許瀏覽器存取裝置感測器（陀螺儀 + 加速度）</li>
                <li><strong>陀螺儀測試：</strong>旋轉手機以查看即時三軸數據</li>
                <li><strong>搖晃測試：</strong>用力搖晃手機觸發搖晃偵測</li>
                <li><strong>螢幕捕獲：</strong>點擊「開始捕獲」按鈕，選擇要捕獲的螢幕或視窗</li>
                <li><strong>數據說明：</strong>
                    <ul style="margin-top: 10px; padding-left: 20px;">
                        <li>X軸 (Alpha): 手機繞Z軸旋轉 (0-360度)</li>
                        <li>Y軸 (Beta): 手機前後傾斜 (-180到180度)</li>
                        <li>Z軸 (Gamma): 手機左右傾斜 (-90到90度)</li>
                        <li>搖晃偵測: 基於加速度變化量 (10+ m/s²)</li>
                        <li>螢幕捕獲: 支援全螢幕、視窗、標籤頁捕獲，15fps串流</li>
                    </ul>
                </li>
            </ul>
        </div>
        
        <div class="deploy-info" style="border-left-color: #FF6B6B;">
            <h3>🔧 v2.0 技術規格</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0;">
                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
                    <h4 style="color: #FFD700; margin-top: 0;">搖晃偵測</h4>
                    <p><strong>演算法：</strong>加速度變化量檢測</p>
                    <p><strong>閾值：</strong>10-15 m/s²</p>
                    <p><strong>防誤判：</strong>連續3次超標</p>
                    <p><strong>響應時間：</strong>&lt; 100ms</p>
                </div>
                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
                    <h4 style="color: #FFD700; margin-top: 0;">感測器支援</h4>
                    <p><strong>陀螺儀：</strong>DeviceOrientationEvent</p>
                    <p><strong>加速度：</strong>DeviceMotionEvent</p>
                    <p><strong>平台：</strong>iOS 13+ / Android</p>
                    <p><strong>權限：</strong>自動請求</p>
                </div>
                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
                    <h4 style="color: #FFD700; margin-top: 0;">數據傳輸</h4>
                    <p><strong>協議：</strong>WebSocket (WSS)</p>
                    <p><strong>頻率：</strong>即時傳輸</p>
                    <p><strong>格式：</strong>JSON</p>
                    <p><strong>服務器：</strong>Railway.app</p>
                </div>
                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
                    <h4 style="color: #FFD700; margin-top: 0;">視覺效果</h4>
                    <p><strong>動畫：</strong>CSS3 動畫</p>
                    <p><strong>回饋：</strong>顏色 + 震動效果</p>
                    <p><strong>響應式：</strong>適配各種螢幕</p>
                    <p><strong>主題：</strong>現代化設計</p>
                </div>
                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
                    <h4 style="color: #FFD700; margin-top: 0;">螢幕捕獲</h4>
                    <p><strong>解析度：</strong>1280x720</p>
                    <p><strong>幀率：</strong>15fps</p>
                    <p><strong>編碼：</strong>JPEG 70%品質</p>
                    <p><strong>傳輸：</strong>WebSocket即時</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 搖晃偵測相關變數 - 基於推薦方式優化
        let shakeCount = 0;
        let lastShakeTime = 0;
        let lastAcceleration = { x: 0, y: 0, z: 0 };
        let accelerationHistory = [];
        let consecutiveHighAcceleration = 0; // 連續高加速度計數
        
        // 閾值設定 - 基於推薦的標準
        const SHAKE_THRESHOLD = 10; // 搖晃閾值 (m/s²) - 推薦的 10-12 m/s²
        const INTENSE_SHAKE_THRESHOLD = 15; // 劇烈搖晃閾值 (m/s²)
        const CONSECUTIVE_SAMPLES = 3; // 連續超標樣本數 - 避免誤判
        const SHAKE_COOLDOWN = 1000; // 搖晃冷卻時間 (毫秒)
        const HISTORY_LENGTH = 20; // 加速度歷史記錄長度
        const GRAVITY = 9.8; // 重力加速度
        
        // 檢查感測器支援
        function checkSensorSupport() {
            const statusElement = document.getElementById('status');
            let hasOrientation = false;
            let hasAcceleration = false;
            
            // 檢查陀螺儀支援
            if (typeof DeviceOrientationEvent !== 'undefined') {
                hasOrientation = true;
            }
            
            // 檢查加速度感測器支援
            if (typeof DeviceMotionEvent !== 'undefined') {
                hasAcceleration = true;
            }
            
            if (hasOrientation && hasAcceleration) {
                if (typeof DeviceOrientationEvent.requestPermission === 'function' || 
                    typeof DeviceMotionEvent.requestPermission === 'function') {
                    // iOS 13+ 需要請求權限
                    statusElement.innerHTML = '點擊任意處以請求感測器權限...';
                    statusElement.className = 'status not-supported';
                    
                    document.addEventListener('click', requestPermissions, { once: true });
                } else {
                    // 其他瀏覽器直接支援
                    statusElement.innerHTML = '✅ 陀螺儀與加速度感測器支援已啟用';
                    statusElement.className = 'status supported';
                    startSensors();
                }
            } else if (hasOrientation) {
                statusElement.innerHTML = '⚠️ 僅支援陀螺儀，無加速度感測器';
                statusElement.className = 'status not-supported';
            } else {
                statusElement.innerHTML = '❌ 此瀏覽器不支援感測器功能';
                statusElement.className = 'status not-supported';
            }
        }
        
        // 請求權限 (iOS)
        async function requestPermissions() {
            try {
                const statusElement = document.getElementById('status');
                let orientationPermission = 'granted';
                let motionPermission = 'granted';
                
                // 請求陀螺儀權限
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    orientationPermission = await DeviceOrientationEvent.requestPermission();
                }
                
                // 請求加速度感測器權限
                if (typeof DeviceMotionEvent.requestPermission === 'function') {
                    motionPermission = await DeviceMotionEvent.requestPermission();
                }
                
                if (orientationPermission === 'granted' && motionPermission === 'granted') {
                    statusElement.innerHTML = '✅ 感測器權限已授予';
                    statusElement.className = 'status supported';
                    startSensors();
                } else {
                    statusElement.innerHTML = '❌ 感測器權限被拒絕';
                    statusElement.className = 'status not-supported';
                }
            } catch (error) {
                console.error('權限請求失敗:', error);
                document.getElementById('status').innerHTML = '❌ 權限請求失敗';
                document.getElementById('status').className = 'status not-supported';
            }
        }
        
        // WebSocket連接管理
        class GyroscopeWebSocket {
            constructor() {
                this.ws = null;
                this.isConnected = false;
                this.onConnectedCallback = null;
                this.webrtcCapture = null; // WebRTC 實例引用
                this.room = null;
                this.role = null;
            }
            
            connect() {
                // 防止重複連線：若已連線或正在連線則略過
                if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
                    console.log('ℹ️ WebSocket 已在連線或連線中，略過重複連線');
                    return;
                }
                const wsUrl = 'wss://testgyroscopehtml-production.up.railway.app';
                console.log('嘗試連接WebSocket:', wsUrl);
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    console.log('✅ WebSocket連接已建立');
                    this.isConnected = true;
                    if (this.onConnectedCallback) {
                        this.onConnectedCallback();
                    }
                };
                
                this.ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        
                        // 處理 ready 消息（房間配對完成）
                        if (data.type === 'ready') {
                            console.log('🤝 房間配對完成:', data.message);
                            // 不要 return，讓後續信令也能被處理
                        }
                        
                        // WebRTC 原生三型別
                        if (['offer', 'answer', 'candidate'].includes(data.type)) {
                            if (this.webrtcCapture) {
                                this.webrtcCapture.handleSignaling(data);
                            }
                            return;
                        }
                        
                        // 房間加入確認
                        if (data.type === 'joined') {
                            console.log(`✅ 已加入房間: ${data.room} as ${data.role}`);
                            return;
                        }
                        
                        // 保留現有消息處理
                        if (data.type === 'ack') {
                            console.log('✅ 數據已成功發送');
                        }
                    } catch (error) {
                        console.error('解析WebSocket訊息錯誤:', error);
                    }
                };
                
                this.ws.onclose = (event) => {
                    console.log('❌ WebSocket連接已關閉:', event.code, event.reason);
                    this.isConnected = false;
                };
                
                this.ws.onerror = (error) => {
                    console.error('❌ WebSocket錯誤:', error);
                };
            }
            
            sendGyroscopeData(alpha, beta, gamma) {
                if (this.isConnected && this.ws && this.ws.readyState === WebSocket.OPEN) {
                    const data = {
                        type: 'gyroscope',
                        alpha: alpha,
                        beta: beta,
                        gamma: gamma,
                        timestamp: Date.now()
                    };
                    console.log('📤 發送陀螺儀數據:', data);
                    this.ws.send(JSON.stringify(data));
                }
            }
            
            sendShakeEvent(count, intensity, acceleration, shakeType = 'normal') {
                if (this.isConnected && this.ws && this.ws.readyState === WebSocket.OPEN) {
                    const data = {
                        type: 'shake',
                        data: {
                            count: count,
                            intensity: intensity,
                            acceleration: acceleration,
                            shakeType: shakeType,
                            timestamp: Date.now()
                        }
                    };
                    console.log('📤 發送搖晃事件:', data);
                    this.ws.send(JSON.stringify(data));
                }
            }
            
            sendScreenCaptureData(imageData, size) {
                if (this.isConnected && this.ws && this.ws.readyState === WebSocket.OPEN) {
                    // 雙包傳輸：先發送header
                    const header = {
                        type: 'screen_capture_header',
                        clientId: this.clientId || 0,
                        timestamp: Date.now(),
                        size: size
                    };
                    this.ws.send(JSON.stringify(header));
                    
                    // 再發送二進位數據
                    this.ws.send(imageData);
                    
                    console.log('📤 發送螢幕捕獲: header + binary data', { 
                        clientId: header.clientId, 
                        size: size, 
                        timestamp: header.timestamp 
                    });
                }
            }
            
            sendSpinEvent(angle, timestamp) {
                console.log('🎯 sendSpinEvent 被调用:', { angle, timestamp, isConnected: this.isConnected, wsState: this.ws?.readyState });
                
                if (this.isConnected && this.ws && this.ws.readyState === WebSocket.OPEN) {
                    const data = {
                        type: 'spin',
                        triggered: true,
                        angle: angle,
                        timestamp: timestamp || Date.now()
                    };
                    console.log('📤 发送旋转事件:', data);
                    this.ws.send(JSON.stringify(data));
                } else {
                    console.warn('⚠️ WebSocket未连接，无法发送旋转事件:', {
                        isConnected: this.isConnected,
                        wsState: this.ws?.readyState
                    });
                }
            }
            
            setOnConnectedCallback(callback) {
                this.onConnectedCallback = callback;
            }
            
            joinRoom(roomId, role) {
                this.room = roomId;
                this.role = role;
                
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'join',
                        room: roomId,
                        role: role
                    }));
                }
            }
            
            send(message) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(message);
                }
            }
        }
        
        // WebRTC 螢幕捕捉類
        class WebRTCScreenCapture {
            constructor(signalingWS, roomId) {
                this.signalingWS = signalingWS;
                this.roomId = roomId;
                this.peerConnection = null;
                this.localStream = null;
                this.iceOk = false;
                this.t1 = null; // 10秒超時計時器
                this.t2 = null; // 18秒降級計時器
                this.mode = 'WebRTC'; // 或 'WebSocket'
                this.stats = { bitrate: 0, fps: 0, rtt: 0, candidateType: 'unknown' };
                this.statsTimer = null;
                
                // ICE 配置：只使用 STUN
                this.rtcConfig = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' }
                    ],
                    iceCandidatePoolSize: 10
                };
            }
            
            async start() {
                try {
                    console.log('🎬 啟動 WebRTC 螢幕捕捉');
                    
                    // 檢查是否已經有流
                    if (this.localStream) {
                        console.log('⚠️ 已有螢幕流，重複使用');
                        return;
                    }
                    
                    // 1. 獲取螢幕流
                    this.localStream = await navigator.mediaDevices.getDisplayMedia({
                        video: {
                            width: { ideal: 1280 },
                            height: { ideal: 720 },
                            frameRate: { ideal: 30, max: 30 }
                        },
                        audio: false
                    });
                    
                    // 2. 設置 contentHint
                    const [videoTrack] = this.localStream.getVideoTracks();
                    videoTrack.contentHint = 'text'; // 文字清晰優先
                    
                    // 3. 設置預覽串流（WebRTC 路徑也要顯示）
                    const videoEl = document.getElementById('screenCaptureVideo');
                    if (videoEl) {
                        videoEl.srcObject = this.localStream;
                        await videoEl.play();
                        console.log('📺 WebRTC 預覽串流已設置');
                    }
                    document.getElementById('screenCapturePreview').style.display = 'block';
                    document.getElementById('captureStatus').textContent = 'WebRTC 串流中';
                    
                    // 4. 監聽用戶停止分享
                    videoTrack.onended = () => {
                        console.log('📺 用戶停止分享');
                        this.teardown(false);
                    };
                    
                    // 5. 創建 RTCPeerConnection
                    this.peerConnection = new RTCPeerConnection(this.rtcConfig);
                    
                    // 6. 添加軌道
                    this.peerConnection.addTrack(videoTrack, this.localStream);
                    
                    // 7. ICE 候選者處理
                    this.peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            this.signalingWS.send(JSON.stringify({
                                type: 'candidate',
                                candidate: event.candidate
                            }));
                        }
                    };
                    
                    // 7. ICE 連接狀態監控
                    this.peerConnection.oniceconnectionstatechange = () => {
                        const state = this.peerConnection.iceConnectionState;
                        console.log('🔌 ICE 狀態:', state);
                        
                        if (state === 'connected' || state === 'completed') {
                            this.iceOk = true;
                            clearTimeout(this.t1);
                            clearTimeout(this.t2);
                            this.updateUI('WebRTC P2P', 'connected');
                        } else if (state === 'failed' || state === 'disconnected') {
                            this.teardown(true);
                        }
                    };
                    
                    // 8. 創建 Offer
                    const offer = await this.peerConnection.createOffer();
                    await this.peerConnection.setLocalDescription(offer);
                    
                    // 9. 發送 Offer
                    this.signalingWS.send(JSON.stringify({
                        type: 'offer',
                        sdp: offer.sdp
                    }));
                    
                    // 10. 設置超時機制
                    this.setupTimeout();
                    
                    // 11. 開始 Stats 監控
                    this.startStatsMonitoring();
                    
                    console.log('✅ WebRTC Offer 已發送');
                    
                } catch (error) {
                    console.error('❌ WebRTC 啟動失敗:', error);
                    this.teardown(true);
                }
            }
            
            setupTimeout() {
                // T+10s：如果還沒連上，嘗試 restartIce
                this.t1 = setTimeout(async () => {
                    if (!this.iceOk) {
                        console.warn('⚠️ 10秒超時，嘗試 restartIce');
                        try {
                            await this.peerConnection.restartIce();
                        } catch (e) {
                            console.error('restartIce 失敗:', e);
                        }
                        
                        // T+18s：仍不通 → 降級
                        this.t2 = setTimeout(() => {
                            if (!this.iceOk) {
                                console.warn('⚠️ 18秒仍未連接，降級到 WebSocket');
                                this.teardown(true);
                            }
                        }, 8000);
                    }
                }, 10000);
            }
            
            async handleSignaling(message) {
                try {
                    if (message.type === 'answer') {
                        const answer = new RTCSessionDescription({
                            type: 'answer',
                            sdp: message.sdp
                        });
                        await this.peerConnection.setRemoteDescription(answer);
                        console.log('✅ 收到 Answer');
                    } else if (message.type === 'candidate') {
                        const candidate = new RTCIceCandidate(message.candidate);
                        await this.peerConnection.addIceCandidate(candidate);
                        console.log('✅ 添加 ICE 候選者');
                    }
                } catch (error) {
                    console.error('❌ 處理信令失敗:', error);
                }
            }
            
            startStatsMonitoring() {
                let last = { bytes: 0, ts: 0, frames: 0 };
                this.statsTimer = setInterval(async () => {
                    if (!this.peerConnection || this.peerConnection.connectionState !== 'connected') return;

                    const stats = await this.peerConnection.getStats();
                    let remoteCand = {}, pair, outbound;

                    stats.forEach(r => {
                        if (r.type === 'candidate-pair' && r.state === 'succeeded') pair = r;
                        if (r.type === 'remote-candidate') remoteCand[r.id] = r;
                        if (r.type === 'outbound-rtp' && r.kind === 'video') outbound = r;
                    });

                    if (outbound) {
                        const now = outbound.timestamp;       // ms
                        const bytes = outbound.bytesSent || 0;
                        const frames = outbound.framesEncoded ?? 0;

                        if (last.ts) {
                            const dt = (now - last.ts) / 1000;  // s
                            const db = bytes - last.bytes;
                            const df = frames - last.frames;
                            this.stats.bitrate = Math.max(0, Math.round((db * 8) / 1000 / dt)); // kbps
                            this.stats.fps = Math.max(0, Math.round(df / dt));
                        }
                        last = { bytes, ts: now, frames };
                    }

                    if (pair) {
                        this.stats.rtt = pair.currentRoundTripTime ? Math.round(pair.currentRoundTripTime * 1000) : 0;
                        // 解析 candidate type（host/srflx/relay）
                        const rcId = pair.remoteCandidateId;
                        const rc = rcId ? remoteCand[rcId] : null;
                        if (rc && rc.candidateType) this.stats.candidateType = rc.candidateType;
                    }

                    this.updateStatsUI();
                }, 2000);
            }
            
            updateStatsUI() {
                const bitrateEl = document.getElementById('webrtcBitrate');
                const fpsEl = document.getElementById('webrtcFPS');
                const rttEl = document.getElementById('webrtcRTT');
                const candidateEl = document.getElementById('webrtcCandidate');
                
                if (bitrateEl) bitrateEl.textContent = `${this.stats.bitrate} kbps`;
                if (fpsEl) fpsEl.textContent = `${this.stats.fps} fps`;
                if (rttEl) rttEl.textContent = `${this.stats.rtt.toFixed(0)} ms`;
                if (candidateEl) candidateEl.textContent = this.stats.candidateType;
            }
            
            updateUI(mode, state) {
                const modeEl = document.getElementById('transferMode');
                const stateEl = document.getElementById('connectionState');
                
                if (modeEl) modeEl.textContent = mode;
                if (stateEl) stateEl.textContent = state;
            }
            
            teardown(fallbackToWS) {
                console.log('🛑 清理 WebRTC 資源');
                
                // 停止所有軌道
                try {
                    this.localStream?.getTracks().forEach(track => track.stop());
                } catch (e) {}
                
                // 停止 PeerConnection 的 senders
                try {
                    this.peerConnection?.getSenders().forEach(sender => {
                        if (sender.track) sender.track.stop();
                    });
                } catch (e) {}
                
                // 關閉 PeerConnection
                try {
                    this.peerConnection?.close();
                } catch (e) {}
                
                // 清理計時器
                clearTimeout(this.t1);
                clearTimeout(this.t2);
                clearInterval(this.statsTimer);
                
                this.mode = 'WebSocket';
                
                // 降級到 WebSocket
                if (fallbackToWS) {
                    this.updateUI('WebSocket 中繼', 'fallback');
                    startWebSocketScreenCapture();
                }
            }
        }
        
        // 建立WebSocket實例
        const gyroWS = new GyroscopeWebSocket();
        
        // 螢幕捕獲相關變數
        let screenCaptureStream = null;
        let screenCaptureCanvas = null;
        let screenCaptureCtx = null;
        let isScreenCapturing = false;
        let screenCaptureFrameCount = 0;
        let screenCaptureLastTime = Date.now();
        let screenCaptureTotalDataSize = 0;
        
        // WebRTC 相關變數
        let webrtcCapture = null;
        let isUsingWebSocket = false;
        
        // 搖晃偵測演算法 - 基於推薦的標準方式
        function detectShake(acceleration) {
            const currentTime = Date.now();
            
            // 1. 讀感測器數據 → 取手機的加速度 (x, y, z)
            const { x, y, z } = acceleration;
            
            // 2. 算合成加速度 → √(x² + y² + z²)
            const currentMagnitude = Math.sqrt(x * x + y * y + z * z);
            
            // 3. 去掉重力影響 → 用變化量 Δa
            const deltaX = Math.abs(x - lastAcceleration.x);
            const deltaY = Math.abs(y - lastAcceleration.y);
            const deltaZ = Math.abs(z - lastAcceleration.z);
            const deltaMagnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);
            
            // 更新加速度歷史
            accelerationHistory.push({
                x: x,
                y: y,
                z: z,
                magnitude: currentMagnitude,
                delta: deltaMagnitude,
                timestamp: currentTime
            });
            
            // 限制歷史記錄長度
            if (accelerationHistory.length > HISTORY_LENGTH) {
                accelerationHistory.shift();
            }
            
            // 調試輸出
            console.log(`🔍 搖晃偵測: 合成加速度=${currentMagnitude.toFixed(2)}, 變化量=${deltaMagnitude.toFixed(2)}, 閾值=${SHAKE_THRESHOLD}, 連續=${consecutiveHighAcceleration}`);
            
            // 4. 設閾值 → Δa 超過 ~10–12 m/s² 才算「劇烈搖晃」
            const isHighAcceleration = deltaMagnitude > SHAKE_THRESHOLD;
            
            // 5. 加上時間條件 → 連續幾個取樣超標才觸發，避免誤判
            if (isHighAcceleration) {
                consecutiveHighAcceleration++;
            } else {
                consecutiveHighAcceleration = 0; // 重置計數
            }
            
            // 檢查是否觸發搖晃事件
            if (consecutiveHighAcceleration >= CONSECUTIVE_SAMPLES && (currentTime - lastShakeTime) > SHAKE_COOLDOWN) {
                shakeCount++;
                lastShakeTime = currentTime;
                consecutiveHighAcceleration = 0; // 重置計數
                
                // 判斷搖晃強度
                let shakeType = 'normal';
                let shakeMessage = '搖晃中！';
                
                if (deltaMagnitude >= INTENSE_SHAKE_THRESHOLD) {
                    shakeType = 'intense';
                    shakeMessage = '劇烈搖晃！';
                } else if (deltaMagnitude >= 12) {
                    shakeType = 'strong';
                    shakeMessage = '強烈搖晃！';
                }
                
                // 更新搖晃狀態顯示
                updateShakeStatus(shakeMessage, true, shakeType);
                
                // 透過WebSocket發送搖晃事件
                gyroWS.sendShakeEvent(shakeCount, deltaMagnitude, acceleration, shakeType);
                
                // 觸發視覺效果
                triggerShakeEffect(shakeType);
                
                console.log(`📳 偵測到${shakeMessage}第 ${shakeCount} 次，變化量: ${deltaMagnitude.toFixed(2)} m/s²，類型: ${shakeType}`);
                
                // 根據搖晃強度調整恢復時間
                const recoveryTime = shakeType === 'intense' ? 1500 : 1000;
                setTimeout(() => {
                    updateShakeStatus('靜止', false);
                }, recoveryTime);
                
                return true;
            }
            
            // 更新最後一次加速度
            lastAcceleration = { x, y, z };
            
            return false;
        }
        
        // 更新搖晃狀態顯示
        function updateShakeStatus(status, isShaking, shakeType = 'normal') {
            const statusElement = document.getElementById('shake-status');
            const countElement = document.getElementById('shake-count');
            const intensityElement = document.getElementById('shake-intensity');
            
            statusElement.textContent = status;
            countElement.textContent = shakeCount;
            
            // 更新搖晃強度顯示
            if (isShaking) {
                let intensityText = '';
                let intensityColor = '';
                
                switch(shakeType) {
                    case 'intense':
                        intensityText = '劇烈';
                        intensityColor = '#FF4444';
                        break;
                    case 'strong':
                        intensityText = '強烈';
                        intensityColor = '#FF8800';
                        break;
                    default:
                        intensityText = '一般';
                        intensityColor = '#FF6B6B';
                }
                
                intensityElement.textContent = intensityText;
                intensityElement.style.color = intensityColor;
            } else {
                intensityElement.textContent = '靜止';
                intensityElement.style.color = '#4ECDC4';
            }
            
            // 添加搖晃效果
            if (isShaking) {
                statusElement.parentElement.classList.add('shake-detected');
                
                // 根據搖晃類型添加不同的視覺效果
                if (shakeType === 'intense') {
                    statusElement.parentElement.style.background = 'linear-gradient(45deg, #FF4444, #FF6666)';
                } else if (shakeType === 'strong') {
                    statusElement.parentElement.style.background = 'linear-gradient(45deg, #FF8800, #FFAA44)';
                } else {
                    statusElement.parentElement.style.background = 'linear-gradient(45deg, #FF6B6B, #FF8E8E)';
                }
                
                setTimeout(() => {
                    statusElement.parentElement.classList.remove('shake-detected');
                    statusElement.parentElement.style.background = '';
                }, 500);
            }
        }
        
        // 觸發搖晃視覺效果
        function triggerShakeEffect(shakeType = 'normal') {
            let animationDuration = '0.3s';
            let animationIntensity = 'shakePulse';
            
            // 根據搖晃類型調整動畫效果
            if (shakeType === 'intense') {
                animationDuration = '0.5s';
                animationIntensity = 'shakePulseIntense';
            } else if (shakeType === 'strong') {
                animationDuration = '0.4s';
                animationIntensity = 'shakePulseStrong';
            }
            
            document.body.style.animation = `${animationIntensity} ${animationDuration} ease-in-out`;
            setTimeout(() => {
                document.body.style.animation = '';
            }, parseFloat(animationDuration) * 1000);
        }
        
        // 開始感測器監聽
        function startSensors() {
            // 此處不再重複連線，載入時已先嘗試連線
            
            // 設置連接成功後的回調
            gyroWS.setOnConnectedCallback(() => {
                console.log('🎯 WebSocket連接成功，開始感測器監聽');
            });
            
            let dataHistory = [];
            const maxHistory = 100;
            
            // 陀螺儀監聽
            window.addEventListener('deviceorientation', function(event) {
                // 更新數值顯示
                updateDisplay(event.alpha, event.beta, event.gamma);
                
                // 更新圖表
                updateChart(event.alpha, event.beta, event.gamma);
                
                // 透過WebSocket發送數據
                gyroWS.sendGyroscopeData(event.alpha, event.beta, event.gamma);
                
                // 儲存歷史數據
                dataHistory.push({
                    alpha: event.alpha,
                    beta: event.beta,
                    gamma: event.gamma,
                    timestamp: Date.now()
                });
                
                // 限制歷史數據長度
                if (dataHistory.length > maxHistory) {
                    dataHistory.shift();
                }
            });
            
            // 加速度感測器監聽
            window.addEventListener('devicemotion', function(event) {
                const acceleration = event.accelerationIncludingGravity;
                
                if (acceleration) {
                    // 更新加速度強度顯示
                    const magnitude = Math.sqrt(
                        acceleration.x * acceleration.x + 
                        acceleration.y * acceleration.y + 
                        acceleration.z * acceleration.z
                    );
                    
                    document.getElementById('acceleration-magnitude').textContent = magnitude.toFixed(2);
                    
                    // 執行搖晃偵測
                    detectShake(acceleration);
                }
            });
        }
        
        // 更新顯示數值
        function updateDisplay(alpha, beta, gamma) {
            document.getElementById('alpha').textContent = formatValue(alpha);
            document.getElementById('beta').textContent = formatValue(beta);
            document.getElementById('gamma').textContent = formatValue(gamma);
        }
        
        // 格式化數值
        function formatValue(value) {
            if (value === null) return 'N/A';
            return value.toFixed(2);
        }
        
        // 更新圖表
        function updateChart(alpha, beta, gamma) {
            const chartWidth = document.getElementById('chart').offsetWidth;
            
            // 將角度轉換為圖表位置 (0-100%)
            const alphaPos = ((alpha || 0) / 360) * 100;
            const betaPos = (((beta || 0) + 180) / 360) * 100;
            const gammaPos = (((gamma || 0) + 90) / 180) * 100;
            
            // 更新線條位置
            document.getElementById('alpha-line').style.left = Math.max(0, Math.min(100, alphaPos)) + '%';
            document.getElementById('beta-line').style.left = Math.max(0, Math.min(100, betaPos)) + '%';
            document.getElementById('gamma-line').style.left = Math.max(0, Math.min(100, gammaPos)) + '%';
        }
        
        // 等待 WebSocket 連接就緒
        function waitForWebSocketReady() {
            return new Promise((resolve, reject) => {
                if (gyroWS.ws && gyroWS.ws.readyState === WebSocket.OPEN) {
                    resolve();
                    return;
                }
                
                const checkInterval = setInterval(() => {
                    if (gyroWS.ws && gyroWS.ws.readyState === WebSocket.OPEN) {
                        clearInterval(checkInterval);
                        resolve();
                    }
                }, 100);
                
                // 10秒超時
                setTimeout(() => {
                    clearInterval(checkInterval);
                    reject(new Error('WebSocket 連接超時'));
                }, 10000);
            });
        }
        
        // 等待房間配對完成
        function waitForRoomReady() {
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    console.warn('⚠️ 房間配對超時，直接開始 WebRTC');
                    resolve(); // 改為 resolve 而不是 reject，讓 WebRTC 嘗試連接
                }, 10000); // 10秒超時
                
                const messageHandler = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'ready') {
                            console.log('🤝 收到房間配對完成通知:', data.message);
                            clearTimeout(timeout);
                            gyroWS.ws.removeEventListener('message', messageHandler);
                            resolve();
                        }
                    } catch (e) {
                        // 忽略解析錯誤
                    }
                };
                
                // 確保 WebSocket 已連接
                if (gyroWS.ws && gyroWS.ws.readyState === WebSocket.OPEN) {
                    gyroWS.ws.addEventListener('message', messageHandler);
                } else {
                    // 如果 WebSocket 未連接，等待連接後再添加監聽器
                    waitForWebSocketReady().then(() => {
                        gyroWS.ws.addEventListener('message', messageHandler);
                    }).catch(() => {
                        clearTimeout(timeout);
                        resolve(); // 超時時仍然 resolve
                    });
                }
            });
        }
        
        // 螢幕捕獲功能
        let isStartingCapture = false; // 防止重複點擊
        
        async function startScreenCapture() {
            if (isStartingCapture) {
                console.log('⚠️ 螢幕捕獲正在啟動中，請稍候...');
                return;
            }
            
            try {
                isStartingCapture = true;
                console.log('🎬 開始螢幕捕獲...');
                
                // 檢查 WebRTC 支援
                if (!window.RTCPeerConnection) {
                    console.warn('⚠️ 不支援 WebRTC，使用 WebSocket');
                    startWebSocketScreenCapture();
                    return;
                }
                
                // 等待 WebSocket 連接就緒
                await waitForWebSocketReady();
                
                // 生成房間 ID
                const roomId = 'default-room';
                
                // 加入房間
                gyroWS.joinRoom(roomId, 'web-sender');
                
                // 等待房間配對完成
                await waitForRoomReady();
                
                console.log('🤝 房間配對完成，開始 WebRTC');
                
                // 現在才開始 WebRTC
                webrtcCapture = new WebRTCScreenCapture(gyroWS.ws, roomId);
                gyroWS.webrtcCapture = webrtcCapture;
                
                await webrtcCapture.start();
                
                // 更新 UI
                document.getElementById('startScreenCapture').style.display = 'none';
                document.getElementById('stopScreenCapture').style.display = 'inline-block';
                document.getElementById('screenCapturePreview').style.display = 'block';
                document.getElementById('captureStatus').textContent = 'WebRTC 串流中';
                
            } catch (error) {
                console.error('❌ 螢幕捕捉啟動失敗:', error);
                startWebSocketScreenCapture();
            } finally {
                isStartingCapture = false;
            }
        }
        
        function startWebSocketScreenCapture() {
            console.log('🔄 切換到 WebSocket 模式');
            
            // 停止 WebRTC（如果存在）
            if (webrtcCapture) {
                webrtcCapture.teardown(false);
                webrtcCapture = null;
            }
            
            isUsingWebSocket = true;
            
            // 使用現有的 WebSocket 螢幕捕捉邏輯
            startWebSocketScreenCaptureImpl();
        }
        
        async function startWebSocketScreenCaptureImpl() {
            try {
                console.log('🎬 開始 WebSocket 螢幕捕獲...');
                
                // 請求螢幕捕獲權限
                screenCaptureStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        mediaSource: 'screen',
                        width: { ideal: 1280, max: 1920 },
                        height: { ideal: 720, max: 1080 },
                        frameRate: { ideal: 15, max: 30 }
                    },
                    audio: false
                });
                
                console.log('✅ 螢幕捕獲權限已獲得');
                console.log('📺 捕獲的畫面範圍:', screenCaptureStream.getVideoTracks()[0].label);
                
                // 顯示本地預覽
                const video = document.getElementById('screenCaptureVideo');
                video.srcObject = screenCaptureStream;
                await video.play();
                
                // 創建Canvas用於捕獲幀
                screenCaptureCanvas = document.createElement('canvas');
                screenCaptureCanvas.width = 1280;
                screenCaptureCanvas.height = 720;
                screenCaptureCtx = screenCaptureCanvas.getContext('2d');
                
                // 開始捕獲幀
                isScreenCapturing = true;
                captureScreenFrames();
                
                // 更新UI
                document.getElementById('startScreenCapture').style.display = 'none';
                document.getElementById('stopScreenCapture').style.display = 'inline-block';
                document.getElementById('screenCapturePreview').style.display = 'block';
                document.getElementById('captureStatus').textContent = 'WebSocket 串流中';
                
                // 更新 Stats UI
                updateWebSocketStatsUI('WebSocket 中繼', 'connected', 0, 0, 0, 'unknown');
                
                console.log('📹 WebSocket 螢幕捕獲已開始');
                
            } catch (error) {
                console.error('❌ WebSocket 螢幕捕獲失敗:', error);
                
                let errorMessage = '螢幕捕獲失敗: ';
                if (error.name === 'NotAllowedError') {
                    errorMessage += '用戶拒絕了螢幕捕獲權限';
                } else if (error.name === 'NotFoundError') {
                    errorMessage += '找不到可用的螢幕捕獲源';
                } else {
                    errorMessage += error.message;
                }
                
                alert(errorMessage);
            }
        }
        
        function stopScreenCapture() {
            isScreenCapturing = false;
            
            if (screenCaptureStream) {
                screenCaptureStream.getTracks().forEach(track => track.stop());
                screenCaptureStream = null;
            }
            
            const video = document.getElementById('screenCaptureVideo');
            video.srcObject = null;
            
            // 更新UI
            document.getElementById('startScreenCapture').style.display = 'inline-block';
            document.getElementById('stopScreenCapture').style.display = 'none';
            document.getElementById('screenCapturePreview').style.display = 'none';
            document.getElementById('captureStatus').textContent = '未開始';
            
            console.log('📹 螢幕捕獲已停止');
        }
        
        function captureScreenFrames() {
            if (!isScreenCapturing) return;
            
            const video = document.getElementById('screenCaptureVideo');
            
            // 繪製當前幀到Canvas
            screenCaptureCtx.drawImage(video, 0, 0, screenCaptureCanvas.width, screenCaptureCanvas.height);
            
            // 轉換為JPEG並發送
            screenCaptureCanvas.toBlob((blob) => {
                if (blob && gyroWS.isConnected) {
                    blob.arrayBuffer().then(buffer => {
                        const imageData = new Uint8Array(buffer);
                        gyroWS.sendScreenCaptureData(imageData, buffer.byteLength);
                        
                        // 更新統計數據
                        screenCaptureTotalDataSize += buffer.byteLength;
                        screenCaptureFrameCount++;
                        
                        // 更新 WebSocket Stats
                        updateWebSocketStats();
                    });
                }
            }, 'image/jpeg', 0.7); // 70%品質的JPEG
            
            // 15fps (每66ms一幀)
            setTimeout(() => captureScreenFrames(), 66);
        }
        
        // 更新 WebSocket Stats UI
        function updateWebSocketStatsUI(mode, state, bitrate, fps, rtt, candidate) {
            document.getElementById('webrtc-mode').textContent = mode;
            document.getElementById('webrtc-state').textContent = state;
            document.getElementById('webrtc-bitrate').textContent = bitrate + ' kbps';
            document.getElementById('webrtc-fps').textContent = fps + ' fps';
            document.getElementById('webrtc-rtt').textContent = rtt + ' ms';
            document.getElementById('webrtc-candidate').textContent = candidate;
        }
        
        // 更新 WebSocket 統計數據
        function updateWebSocketStats() {
            const now = Date.now();
            const timeDiff = (now - screenCaptureLastTime) / 1000;
            
            if (timeDiff > 0) {
                const currentFPS = Math.round(screenCaptureFrameCount / timeDiff);
                const currentBitrate = Math.round((screenCaptureTotalDataSize * 8) / (timeDiff * 1000)); // kbps
                
                updateWebSocketStatsUI('WebSocket 中繼', 'connected', currentBitrate, currentFPS, 0, 'unknown');
            }
        }
        
        // 定期更新 WebSocket 統計
        setInterval(() => {
            if (isUsingWebSocket && isScreenCapturing) {
                updateWebSocketStats();
            }
        }, 2000);
        
        // 更新螢幕捕獲統計數據
        function updateScreenCaptureStats() {
            const now = Date.now();
            const timeDiff = (now - screenCaptureLastTime) / 1000;
            
            if (timeDiff > 0) {
                const currentFPS = Math.round(screenCaptureFrameCount / timeDiff);
                document.getElementById('captureFPS').textContent = `${currentFPS} FPS`;
                
                // 重置計數器
                screenCaptureFrameCount = 0;
                screenCaptureLastTime = now;
            }
            
            // 更新數據大小顯示
            const sizeInKB = Math.round(screenCaptureTotalDataSize / 1024);
            document.getElementById('captureDataSize').textContent = `${sizeInKB} KB`;
        }
        
        // 添加螢幕捕獲按鈕事件監聽器
        document.addEventListener('DOMContentLoaded', function() {
            const startBtn = document.getElementById('startScreenCapture');
            const stopBtn = document.getElementById('stopScreenCapture');
            
            if (startBtn) {
                startBtn.addEventListener('click', startScreenCapture);
            }
            if (stopBtn) {
                stopBtn.addEventListener('click', stopScreenCapture);
            }
            
            // 開始統計更新
            setInterval(updateScreenCaptureStats, 1000);
        });
        
        // 頁面載入時：先連上 WebSocket，再檢查/請求感測器權限（授權後才開始送資料）
        window.addEventListener('load', function () {
            try {
                if (!gyroWS || !gyroWS.ws || gyroWS.ws.readyState !== WebSocket.OPEN) {
                    gyroWS.connect();
                }
            } catch (e) {
                console.error('初始化 WebSocket 連線時出錯:', e);
            }
            checkSensorSupport();
        });
        
        // 處理視窗大小改變
        window.addEventListener('resize', function() {
            // 重新計算圖表位置
            const alpha = parseFloat(document.getElementById('alpha').textContent);
            const beta = parseFloat(document.getElementById('beta').textContent);
            const gamma = parseFloat(document.getElementById('gamma').textContent);
            
            if (!isNaN(alpha) && !isNaN(beta) && !isNaN(gamma)) {
                updateChart(alpha, beta, gamma);
            }
        });
        
        // ===== SpinTest 旋转控制功能 =====
        
        // 创建音效对象
        const spinSoundEffect = new Audio('se_door_hanekaeri.mp3');
        
        // 创建震动函数
        function triggerSpinVibration(pattern = [100, 50, 100]) {
            console.log("尝试触发旋转震动，模式:", pattern);
            
            if ("vibrate" in navigator) {
                try {
                    const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    console.log("检测到移动设备:", isMobile);
                    
                    if (isMobile) {
                        navigator.vibrate(pattern);
                        console.log("移动设备震动触发:", pattern);
                    } else {
                        console.log("桌面设备，震动功能不可用");
                    }
                } catch (error) {
                    console.log("震动执行失败:", error);
                }
            } else {
                console.log("此设备或浏览器不支援震动功能");
            }
        }
        
        // 初始化旋转控制器
        function initializeSpinController() {
            // 确保 DOM 完全载入后再初始化
            $(document).ready(function() {
                console.log("DOM 已载入，开始初始化旋转控制器...");
                
                // 检查必要的库是否已载入
                if (typeof gsap === 'undefined') {
                    console.error("GSAP 未载入！");
                    return;
                }
                
                if (typeof Draggable === 'undefined') {
                    console.error("Draggable 插件未载入！");
                    return;
                }
                
                // 检查旋钮元素是否存在
                const knobElement = document.getElementById("spinKnob");
                if (!knobElement) {
                    console.error("找不到 #spinKnob 元素！");
                    return;
                }
                
                console.log("开始创建旋转控制器...");
                
                // 创建可拖拽的旋钮
                const draggable = Draggable.create("#spinKnob", {
                    type: "rotation",
                    inertia: true,
                    onDragStart: function() {
                        // 记录开始拖拽时的角度
                        this.startAngle = this.rotation;
                        console.log("开始拖拽，起始角度:", this.startAngle);
                    },
                    onDrag: function() {
                        let currentAngle = this.rotation;
                        let rotationDelta = currentAngle - this.startAngle;
                        
                        // 实时更新角度显示
                        updateSpinAngleDisplay();
                        
                        // 限制旋转增量在 90 度以内
                        if (Math.abs(rotationDelta) > 45) {
                            // 如果旋转超过 45 度，就限制到 90 度
                            let targetAngle = this.startAngle + (rotationDelta > 0 ? 90 : -90);
                            
                            // 强制设定到限制的角度，使用回弹动画
                            gsap.to(this.target, {
                                rotation: targetAngle,
                                duration: 0.4,
                                ease: "elastic.out(1, 0.4)"
                            });
                            
                            // 播放回弹音效
                            spinSoundEffect.currentTime = 0; // 重置音效到开始位置
                            spinSoundEffect.play().catch(e => console.log("音效播放失败:", e));
                            
                            // 发送旋转事件到Unity
                            console.log('🎯 准备发送旋转事件，角度:', targetAngle);
                            gyroWS.sendSpinEvent(targetAngle);
                            
                            // 稍微延迟震动，让声音先开始播放
                            setTimeout(() => {
                                triggerSpinVibration(200); // 设备震动200毫秒
                            }, 50); // 延迟50ms让声音先开始
                            
                            console.log(`旋转被限制到: ${targetAngle}° (增量: ${rotationDelta.toFixed(1)}°)`);
                        } else {
                            console.log("拖拽中，旋转角度:", this.rotation, "增量:", rotationDelta.toFixed(1));
                        }
                    },
                    onDragEnd: function() {
                        // 拖拽结束时进行最终吸附
                        let currentAngle = this.rotation;
                        let rotationDelta = currentAngle - this.startAngle;
                        
                        // 计算最终角度（限制在 90 度增量内）
                        let finalAngle = this.startAngle;
                        if (Math.abs(rotationDelta) > 45) {
                            finalAngle = this.startAngle + (rotationDelta > 0 ? 90 : -90);
                        } else {
                            // 如果增量小于 45 度，回到起始角度
                            finalAngle = this.startAngle;
                        }
                        
                        // 使用强烈的回弹动画吸附到最终角度
                        gsap.to(this.target, {
                            rotation: finalAngle,
                            duration: 0.6,
                            ease: "elastic.out(1, 0.3)"
                        });

                        // 如果最终角度与起始角度不同，播放回弹音效和震动
                        if (finalAngle !== this.startAngle) {
                            spinSoundEffect.currentTime = 0; // 重置音效到开始位置
                            spinSoundEffect.play().catch(e => console.log("音效播放失败:", e));
                            
                            // 发送旋转事件到Unity
                            console.log('🎯 准备发送旋转事件（onDragEnd），角度:', finalAngle);
                            gyroWS.sendSpinEvent(finalAngle);
                            
                            // 稍微延迟震动，让声音先开始
                            setTimeout(() => {
                                triggerSpinVibration(200); // 设备震动200毫秒
                            }, 0); // 延迟50ms让声音先开始
                        }

                        console.log(`拖拽结束，最终角度: ${finalAngle}° (增量: ${rotationDelta.toFixed(1)}°)`);
                        
                        // 更新最终角度显示
                        updateSpinAngleDisplay();
                    }
                });
                
                console.log("旋转控制器创建成功:", draggable);
                
                // 初始化角度显示
                updateSpinAngleDisplay();
                
                console.log("旋转控制器初始化完成！");
            });
        }
        
        // 更新角度显示的函數
        function updateSpinAngleDisplay() {
            const currentRotation = gsap.getProperty("#spinKnob", "rotation");
            $("#spinAngleDisplay").text("当前角度: " + currentRotation.toFixed(1) + "°");
        }
        
        // 页面载入时初始化旋转控制器
        window.addEventListener('load', function () {
            // 延迟初始化，确保其他库已载入
            setTimeout(() => {
                initializeSpinController();
            }, 1000);
        });
    </script>
</body>
</html>
