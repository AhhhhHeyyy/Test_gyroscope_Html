# ğŸ“º å½±åƒæ•æ‰åŠŸèƒ½é–‹ç™¼ç´€éŒ„

## ğŸ¯ åŠŸèƒ½æ¦‚è¿°
**åŠŸèƒ½åç¨±**: å½±åƒæ•æ‰èˆ‡å³æ™‚ä¸²æµç³»çµ±  
**é–‹ç™¼æ™‚é–“**: 2024å¹´10æœˆ  
**æŠ€è¡“æ£§**: WebRTC P2P + WebSocket é™ç´š + Unityæ¥æ”¶ç«¯  
**ä¸»è¦ç›®æ¨™**: å¯¦ç¾ä½å»¶é²ã€é«˜å“è³ªçš„è¢å¹•æ•ç²èˆ‡å³æ™‚å‚³è¼¸åˆ°Unity  

## ğŸ—ï¸ ç³»çµ±æ¶æ§‹è¨­è¨ˆ

### æ•´é«”æ¶æ§‹åœ–
```
æ‰‹æ©Ÿç€è¦½å™¨ (ç™¼é€ç«¯)
â”œâ”€â”€ WebRTC P2P å„ªå…ˆè·¯å¾‘ (100-300mså»¶é²)
â”‚   â”œâ”€â”€ getDisplayMedia() è¢å¹•æ•ç²
â”‚   â”œâ”€â”€ RTCPeerConnection é»å°é»é€£æ¥
â”‚   â””â”€â”€ ç›´æ¥è¦–é »è»Œé“å‚³è¼¸
â””â”€â”€ WebSocket é™ç´šè·¯å¾‘ (500-1000mså»¶é²)
    â”œâ”€â”€ Canvas æ•ç²å¹€
    â”œâ”€â”€ JPEG ç·¨ç¢¼ (70%å“è³ª)
    â””â”€â”€ Base64 æ•¸æ“šå‚³è¼¸

Railway ä¼ºæœå™¨ (ä¿¡ä»¤ä¸­ç¹¼)
â”œâ”€â”€ WebRTC ä¿¡ä»¤è½‰ç™¼ (offer/answer/candidate)
â”œâ”€â”€ æˆ¿é–“é…å°ç®¡ç†
â””â”€â”€ WebSocket è¢å¹•æ•¸æ“šå»£æ’­

Unity æ¥æ”¶ç«¯
â”œâ”€â”€ WebRTCScreenReceiver (P2På„ªå…ˆ)
â”‚   â”œâ”€â”€ è¦–é »è»Œé“æ¥æ”¶
â”‚   â”œâ”€â”€ ç´‹ç†å³æ™‚æ›´æ–°
â”‚   â””â”€â”€ MaterialPropertyBlock å„ªåŒ–
â””â”€â”€ ScreenCaptureHandler (WebSocketé™ç´š)
    â”œâ”€â”€ å¹€æ•¸æ“šè™•ç†
    â”œâ”€â”€ Texture2D é‡å»º
    â””â”€â”€ è‡ªé©æ‡‰å¹€ç‡èª¿æ•´
```

### æŠ€è¡“æ±ºç­–è¨˜éŒ„

#### 1. é›™è·¯å¾‘è¨­è¨ˆæ±ºç­–
**å•é¡Œ**: å¦‚ä½•ç¢ºä¿å½±åƒå‚³è¼¸çš„å¯é æ€§ï¼Ÿ  
**è§£æ±ºæ–¹æ¡ˆ**: WebRTC P2P å„ªå…ˆ + WebSocket é™ç´š  
**ç†ç”±**: 
- WebRTC æä¾›æœ€ä½å»¶é² (100-300ms)
- WebSocket ä½œç‚ºå‚™ç”¨æ–¹æ¡ˆç¢ºä¿é€£æ¥ç©©å®šæ€§
- è‡ªå‹•é™ç´šæ©Ÿåˆ¶æå‡ç”¨æˆ¶é«”é©—

#### 2. æˆ¿é–“åˆ¶åº¦è¨­è¨ˆ
**å•é¡Œ**: å¦‚ä½•ç®¡ç†å¤šå°ç«¯é€£æ¥ï¼Ÿ  
**è§£æ±ºæ–¹æ¡ˆ**: æˆ¿é–“é…å°ç³»çµ±  
**å¯¦ç¾**: 
```javascript
// æˆ¿é–“é…å°é‚è¼¯
if (peers.size === 2) {
    // é€šçŸ¥æ‰€æœ‰åŒæˆ¿ peer æº–å‚™å°±ç·’
    for (const peer of peers) {
        peer.send(JSON.stringify({
            type: 'ready',
            room: room,
            message: 'Both peers joined, WebRTC can start'
        }));
    }
}
```

#### 3. æ€§èƒ½å„ªåŒ–ç­–ç•¥
**å•é¡Œ**: å¦‚ä½•å¹³è¡¡å“è³ªèˆ‡æ€§èƒ½ï¼Ÿ  
**è§£æ±ºæ–¹æ¡ˆ**: å¤šå±¤å„ªåŒ–ç­–ç•¥
- **è§£æåº¦**: 1280x720 (å¹³è¡¡å“è³ªèˆ‡é »å¯¬)
- **å¹€ç‡**: 30fps (WebRTC) / 15fps (WebSocket)
- **ç·¨ç¢¼**: H.264 (WebRTC) / JPEG 70% (WebSocket)
- **è¨˜æ†¶é«”**: Texture2D é‡ç”¨ + ä½‡åˆ—é™åˆ¶

## ğŸ“± å‰ç«¯å¯¦ç¾è©³æƒ…

### 1. WebRTC è¢å¹•æ•ç²é¡ (WebRTCScreenCapture)

#### æ ¸å¿ƒåˆå§‹åŒ–æµç¨‹
```javascript
class WebRTCScreenCapture {
    async start() {
        // 1. ç²å–è¢å¹•æµ
        this.localStream = await navigator.mediaDevices.getDisplayMedia({
            video: {
                width: { ideal: 1280 },
                height: { ideal: 720 },
                frameRate: { ideal: 30, max: 30 }
            },
            audio: false
        });
        
        // 2. è¨­ç½® contentHint
        const [videoTrack] = this.localStream.getVideoTracks();
        videoTrack.contentHint = 'text'; // æ–‡å­—æ¸…æ™°å„ªå…ˆ
        
        // 3. å‰µå»º RTCPeerConnection
        this.peerConnection = new RTCPeerConnection(this.rtcConfig);
        
        // 4. æ·»åŠ è»Œé“
        this.peerConnection.addTrack(videoTrack, this.localStream);
        
        // 5. å‰µå»ºä¸¦ç™¼é€ Offer
        const offer = await this.peerConnection.createOffer();
        await this.peerConnection.setLocalDescription(offer);
        this.signalingWS.send(JSON.stringify({
            type: 'offer',
            sdp: offer.sdp
        }));
    }
}
```

#### ICE é€£æ¥ç‹€æ…‹ç›£æ§
```javascript
this.peerConnection.oniceconnectionstatechange = () => {
    const state = this.peerConnection.iceConnectionState;
    console.log('ğŸ”Œ ICE ç‹€æ…‹:', state);
    
    if (state === 'connected' || state === 'completed') {
        this.iceOk = true;
        this.updateUI('WebRTC P2P', 'connected');
    } else if (state === 'failed' || state === 'disconnected') {
        this.teardown(true); // é™ç´šåˆ° WebSocket
    }
};
```

#### æ€§èƒ½çµ±è¨ˆç›£æ§
```javascript
startStatsMonitoring() {
    this.statsTimer = setInterval(async () => {
        const stats = await this.peerConnection.getStats();
        let outbound, pair;
        
        stats.forEach(r => {
            if (r.type === 'candidate-pair' && r.state === 'succeeded') pair = r;
            if (r.type === 'outbound-rtp' && r.kind === 'video') outbound = r;
        });
        
        if (outbound) {
            const dt = (outbound.timestamp - last.ts) / 1000;
            const db = outbound.bytesSent - last.bytes;
            this.stats.bitrate = Math.round((db * 8) / 1000 / dt); // kbps
            this.stats.fps = Math.round((outbound.framesEncoded - last.frames) / dt);
        }
        
        if (pair) {
            this.stats.rtt = Math.round(pair.currentRoundTripTime * 1000);
        }
        
        this.updateStatsUI();
    }, 2000);
}
```

### 2. WebSocket é™ç´šå¯¦ç¾

#### Canvas æ•ç²æµç¨‹
```javascript
function captureScreenFrames() {
    if (!isScreenCapturing) return;
    
    const video = document.getElementById('screenCaptureVideo');
    
    // ç¹ªè£½ç•¶å‰å¹€åˆ°Canvas
    screenCaptureCtx.drawImage(video, 0, 0, 
        screenCaptureCanvas.width, screenCaptureCanvas.height);
    
    // è½‰æ›ç‚ºJPEGä¸¦ç™¼é€
    screenCaptureCanvas.toBlob((blob) => {
        if (blob && gyroWS.isConnected) {
            blob.arrayBuffer().then(buffer => {
                const imageData = new Uint8Array(buffer);
                gyroWS.sendScreenCaptureData(imageData, buffer.byteLength);
            });
        }
    }, 'image/jpeg', 0.7); // 70%å“è³ª
    
    // 15fps (æ¯66msä¸€å¹€)
    setTimeout(() => captureScreenFrames(), 66);
}
```

#### é›™åŒ…å‚³è¼¸æ©Ÿåˆ¶
```javascript
sendScreenCaptureData(imageData, size) {
    // é›™åŒ…å‚³è¼¸ï¼šå…ˆç™¼é€header
    const header = {
        type: 'screen_capture_header',
        clientId: this.clientId || 0,
        timestamp: Date.now(),
        size: size
    };
    this.ws.send(JSON.stringify(header));
    
    // å†ç™¼é€äºŒé€²ä½æ•¸æ“š
    this.ws.send(imageData);
}
```

### 3. æ™ºèƒ½é™ç´šæ©Ÿåˆ¶

#### è¶…æ™‚èˆ‡é™ç´šé‚è¼¯
```javascript
setupTimeout() {
    // T+10sï¼šå¦‚æœé‚„æ²’é€£ä¸Šï¼Œå˜—è©¦ restartIce
    this.t1 = setTimeout(async () => {
        if (!this.iceOk) {
            console.warn('âš ï¸ 10ç§’è¶…æ™‚ï¼Œå˜—è©¦ restartIce');
            try {
                await this.peerConnection.restartIce();
            } catch (e) {
                console.error('restartIce å¤±æ•—:', e);
            }
            
            // T+18sï¼šä»ä¸é€š â†’ é™ç´š
            this.t2 = setTimeout(() => {
                if (!this.iceOk) {
                    console.warn('âš ï¸ 18ç§’ä»æœªé€£æ¥ï¼Œé™ç´šåˆ° WebSocket');
                    this.teardown(true);
                }
            }, 8000);
        }
    }, 10000);
}
```

## ğŸ–¥ï¸ ä¼ºæœå™¨ç«¯å¯¦ç¾

### 1. WebSocket ä¼ºæœå™¨é…ç½®

#### æˆ¿é–“ç®¡ç†ç³»çµ±
```javascript
// æˆ¿é–“ç®¡ç†
const rooms = new Map(); // roomId -> Set<WebSocket>

// æˆ¿é–“åŠ å…¥é‚è¼¯
if (msg.type === 'join') {
    const { room, role } = msg; // role: 'web-sender' / 'unity-receiver'
    ws.room = room;
    ws.role = role;
    
    // æª¢æŸ¥æˆ¿é–“é™åˆ¶
    const peers = rooms.get(room) || new Set();
    const sameRole = Array.from(peers).find(p => p.role === role);
    if (sameRole) {
        // è¸¢æ‰èˆŠçš„æˆ–æ‹’çµ•æ–°çš„
        sameRole.close(1000, 'Replaced by new peer');
    }
    
    peers.add(ws);
    rooms.set(room, peers);
    
    // æª¢æŸ¥æˆ¿é–“æ˜¯å¦å·²æ»¿ï¼ˆ2å€‹ peerï¼‰
    if (peers.size === 2) {
        console.log(`ğŸ¤ Room ${room} has both peers ready, notifying all`);
        
        // é€šçŸ¥æ‰€æœ‰åŒæˆ¿ peer æº–å‚™å°±ç·’
        for (const peer of peers) {
            if (peer.readyState === WebSocket.OPEN) {
                peer.send(JSON.stringify({
                    type: 'ready',
                    room: room,
                    message: 'Both peers joined, WebRTC can start'
                }));
            }
        }
    }
}
```

#### WebRTC ä¿¡ä»¤è½‰ç™¼
```javascript
// WebRTC åŸç”Ÿä¸‰å‹åˆ¥è½‰ç™¼
if (['offer', 'answer', 'candidate'].includes(msg.type)) {
    if (!ws.room) {
        console.warn(`âš ï¸ WebSocket ${ws.id} æ²’æœ‰æˆ¿é–“ä¿¡æ¯ï¼Œç„¡æ³•è½‰ç™¼ä¿¡ä»¤`);
        return;
    }
    
    const peers = rooms.get(ws.room) || new Set();
    
    for (const peer of peers) {
        if (peer !== ws && peer.readyState === WebSocket.OPEN) {
            peer.send(JSON.stringify(msg));
            console.log(`ğŸ“¤ å·²è½‰ç™¼ ${msg.type} çµ¦ ${peer.role}`);
        }
    }
    
    // æ›´æ–°çµ±è¨ˆ
    if (msg.type === 'offer') stats.webrtcOffers++;
    else if (msg.type === 'answer') stats.webrtcAnswers++;
    else if (msg.type === 'candidate') stats.webrtcCandidates++;
}
```

#### è¢å¹•æ•ç²æ•¸æ“šè™•ç†
```javascript
// äºŒé€²ä½æ•¸æ“šï¼šåƒ…ç”¨æ–¼è¢å¹•æ•ç²å¹€
if (isBinary) {
    if (ws.screenCaptureHeader) {
        const header = ws.screenCaptureHeader;
        const bytes = Buffer.isBuffer(data) ? new Uint8Array(data) : new Uint8Array();
        const imageData = Array.from(bytes);
        
        stats.screenCaptureMessages++;
        
        const out = {
            type: 'screen_capture',
            clientId: header.clientId,
            timestamp: header.timestamp,
            size: header.size,
            image: imageData
        };
        
        // å»£æ’­çµ¦æ‰€æœ‰å®¢æˆ¶ç«¯
        clients.forEach(client => {
            if (client.readyState === WebSocket.OPEN) {
                try {
                    client.send(JSON.stringify(out));
                } catch (e) {
                    console.error('âŒ å»£æ’­å¤±æ•—:', e);
                }
            }
        });
        
        // æ¸…é™¤header
        delete ws.screenCaptureHeader;
    }
}
```

## ğŸ® Unity æ¥æ”¶ç«¯å¯¦ç¾

### 1. WebRTCScreenReceiver é¡

#### æ ¸å¿ƒåˆå§‹åŒ–
```csharp
void Start()
{
    Debug.Log("ğŸš€ WebRTC æº–å‚™å°±ç·’");
    
    // ICE é…ç½®
    config = new RTCConfiguration
    {
        iceServers = new[] { 
            new RTCIceServer { urls = new[] { "stun:stun.l.google.com:19302" } },
            new RTCIceServer { urls = new[] { "stun:stun1.l.google.com:19302" } }
        },
        iceCandidatePoolSize = 10
    };
    
    // åˆå§‹åŒ– MaterialPropertyBlock
    _mpb = new MaterialPropertyBlock();
    EnsureTargetRendererHasMaterial();
    
    // è¨‚é–±ä¿¡ä»¤äº‹ä»¶
    GyroscopeReceiver.OnWebRTCSignaling += HandleSignaling;
    GyroscopeReceiver.OnRawMessage += HandleSignalingText;
}
```

#### Offer è™•ç†æµç¨‹
```csharp
IEnumerator AcceptOffer(string sdp)
{
    Debug.Log($"ğŸ¯ é–‹å§‹è™•ç† Offer SDP: {sdp.Substring(0, Math.Min(30, sdp.Length))}...");
    
    // æ¸…ç†èˆŠçš„é€£æ¥
    if (peerConnection != null)
    {
        peerConnection.Close();
        peerConnection.Dispose();
    }
    
    // å‰µå»ºæ–°çš„ PeerConnection
    peerConnection = new RTCPeerConnection(ref config);
    
    // ICE å€™é¸è€…è™•ç†
    peerConnection.OnIceCandidate = candidate =>
    {
        if (candidate == null) return;
        
        var candidateDto = new GyroscopeReceiver.SignalingDTO
        {
            type = "candidate",
            candidate = new GyroscopeReceiver.IceCandidateDTO
            {
                candidate = candidate.Candidate,
                sdpMid = candidate.SdpMid,
                sdpMLineIndex = candidate.SdpMLineIndex ?? 0
            }
        };
        gyroscopeReceiver.SendSignaling(candidateDto);
    };
    
    // ICE é€£æ¥ç‹€æ…‹æ”¹è®Š
    peerConnection.OnIceConnectionChange = state =>
    {
        this.iceConnectionState = state.ToString();
        Debug.Log($"ğŸ”Œ ICE ç‹€æ…‹: {state}");
        
        if (state == RTCIceConnectionState.Connected || state == RTCIceConnectionState.Completed)
        {
            isConnected = true;
            isWebRTCMode = true;
            Debug.Log("ğŸ‰ WebRTC é€£æ¥æˆåŠŸï¼");
            
            // åœç”¨ WebSocket æ¨¡å¼
            var handler = GetComponent<ScreenCaptureHandler>();
            if (handler) handler.enabled = false;
        }
        else if (state == RTCIceConnectionState.Failed || state == RTCIceConnectionState.Disconnected)
        {
            Debug.LogWarning("âš ï¸ ICE é€£æ¥å¤±æ•—ï¼Œé™ç´šåˆ° WebSocket");
            FallbackToWebSocket();
        }
    };
    
    // æ¥æ”¶é ç«¯è»Œé“
    peerConnection.OnTrack = (RTCTrackEvent e) =>
    {
        if (e.Track is VideoStreamTrack vtrack)
        {
            Debug.Log("ğŸ“º æ”¶åˆ°è¦–é »è»Œé“");
            remoteVideoTrack = vtrack;
            
            // æ¨™è¨˜æœ‰æ–°ç´‹ç†ï¼Œåœ¨ä¸»ç·šç¨‹ Update ä¸­è™•ç†
            vtrack.OnVideoReceived += (tex) => {
                Debug.Log($"ğŸ“º æ”¶åˆ°è¦–é »å¹€: {tex.width}x{tex.height}");
                _pendingTex = tex;
                _hasNewTex = true;
            };
        }
    };
    
    // è¨­ç½®é ç«¯æè¿°
    var desc = new RTCSessionDescription { type = RTCSdpType.Offer, sdp = sdp };
    var setOp = peerConnection.SetRemoteDescription(ref desc);
    yield return setOp;
    
    // å‰µå»º Answer
    var answerOp = peerConnection.CreateAnswer();
    yield return answerOp;
    var answer = answerOp.Desc;
    
    // è¨­ç½®æœ¬åœ°æè¿°
    var setLocalOp = peerConnection.SetLocalDescription(ref answer);
    yield return setLocalOp;
    
    // ç™¼é€ Answer
    var answerDto = new GyroscopeReceiver.SignalingDTO
    {
        type = "answer",
        sdp = answer.sdp
    };
    gyroscopeReceiver.SendSignaling(answerDto);
    
    // å•Ÿå‹•è¶…æ™‚æª¢æŸ¥
    StartCoroutine(ConnectionTimeoutCheck());
}
```

#### ç´‹ç†è™•ç†å„ªåŒ–
```csharp
void Update()
{
    // WebRTC å…§éƒ¨æ›´æ–°
    WebRTC.Update();
    
    // ä¸»ç·šç¨‹ç´‹ç†æ›´æ–°
    if (_hasNewTex && _pendingTex != null && targetRenderer != null)
    {
        ApplyTextureWithMPB(_pendingTex);
        _hasNewTex = false;
    }
}

private void ApplyTextureWithMPB(Texture tex)
{
    if (targetRenderer == null || tex == null) return;
    
    Material mat = targetRenderer.material;
    
    // æª¢æŸ¥ Shader æ˜¯å¦æ­£ç¢º
    if (mat.shader.name != "Unlit/Texture" && 
        mat.shader.name != "Universal Render Pipeline/Unlit")
    {
        Debug.LogWarning($"âš ï¸ Shader ä¸æ­£ç¢º: {mat.shader.name}ï¼Œå˜—è©¦åˆ‡æ›åˆ° Unlit/Texture");
        var unlitShader = Shader.Find("Unlit/Texture");
        if (unlitShader != null)
        {
            mat.shader = unlitShader;
        }
    }
    
    // æ–¹æ³• 1ï¼šç›´æ¥è¨­ç½® mainTextureï¼ˆå„ªå…ˆï¼‰
    mat.mainTexture = tex;
    
    // æ–¹æ³• 2ï¼šä½¿ç”¨ MaterialPropertyBlock
    targetRenderer.GetPropertyBlock(_mpb);
    _mpb.SetTexture(ID_MainTex, tex);
    _mpb.SetTexture(ID_BaseMap, tex);
    targetRenderer.SetPropertyBlock(_mpb);
    
    Debug.Log($"âœ… MaterialPropertyBlock å¥—ç”¨è¦–é »è²¼åœ–æˆåŠŸ: {tex.width}x{tex.height}");
}
```

### 2. ScreenCaptureHandler é¡ (WebSocket é™ç´š)

#### é™ç´šè™•ç†é‚è¼¯
```csharp
void Start()
{
    // WebSocket æ¨¡å¼ä½œç‚ºé™ç´šæ–¹æ¡ˆ
    // åˆå§‹ç¦ç”¨ï¼Œç­‰ WebRTC å¤±æ•—æ™‚å•Ÿç”¨
    this.enabled = false;
    
    // è¨‚é–±äº‹ä»¶
    GyroscopeReceiver.OnScreenCaptureReceived += HandleScreenFrame;
    
    // åˆå§‹åŒ–
    if (targetRenderer == null)
        targetRenderer = GetComponent<Renderer>();
        
    if (screenMaterial == null)
    {
        screenMaterial = new Material(Shader.Find("Standard"));
        targetRenderer.material = screenMaterial;
    }
    
    adaptiveInterval = baseUpdateInterval;
    
    Debug.Log("ğŸ“º ScreenCaptureHandler å·²åˆå§‹åŒ–ï¼ˆWebSocket é™ç´šæ¨¡å¼ï¼‰");
}
```

#### å¹€è™•ç†èˆ‡æ€§èƒ½å„ªåŒ–
```csharp
void HandleScreenFrame(GyroscopeReceiver.ScreenFrame frame)
{
    // ç«‹å³è™•ç†æ¨¡å¼ï¼šç›´æ¥è™•ç†æœ€æ–°å¹€ï¼Œä¸Ÿæ£„èˆŠçš„
    if (frameQueue.Count >= maxQueueSize)
    {
        frameQueue.TryDequeue(out _);
    }
    
    frameQueue.Enqueue(frame);
    
    // ç«‹å³è™•ç†æœ€æ–°å¹€ä»¥æ¸›å°‘å»¶é²
    ProcessNextFrame();
    
    Debug.Log($"ğŸ“º æ”¶åˆ°è¢å¹•å¹€: ClientId={frame.clientId}, Size={frame.size} bytes, ä½‡åˆ—={frameQueue.Count}");
}

void ProcessFrame(GyroscopeReceiver.ScreenFrame frame)
{
    try
    {
        // é‡ç”¨ Texture2D
        if (screenTexture == null)
        {
            screenTexture = new Texture2D(2, 2, TextureFormat.RGBA32, false);
        }
        
        // è¼‰å…¥åœ–åƒï¼ˆæ¨™è¨˜ç‚ºä¸å¯è®€ï¼Œæ¸›å°‘è¨˜æ†¶é«”ä½¿ç”¨ï¼‰
        if (screenTexture.LoadImage(frame.data, true))
        {
            // æ‡‰ç”¨åˆ°æè³ª
            screenMaterial.mainTexture = screenTexture;
            targetRenderer.material = screenMaterial;
            
            frameCount++;
            Debug.Log($"ğŸ“º è™•ç†è¢å¹•å¹€ #{frameCount} (ClientId: {frame.clientId}, Size: {frame.size} bytes)");
        }
        else
        {
            Debug.LogError("âŒ ç„¡æ³•è¼‰å…¥è¢å¹•æ•ç²æ•¸æ“š");
        }
    }
    catch (System.Exception e)
    {
        Debug.LogError($"âŒ è™•ç†è¢å¹•å¹€éŒ¯èª¤: {e.Message}");
    }
}
```

#### è‡ªé©æ‡‰å¹€ç‡èª¿æ•´
```csharp
void UpdateAdaptiveInterval()
{
    // è¨ˆç®—å¹³å‡å¹€æ™‚é–“
    float currentFrameTime = Time.deltaTime;
    frameTimes[frameTimeIndex] = currentFrameTime;
    frameTimeIndex = (frameTimeIndex + 1) % frameTimes.Length;
    
    float avgFrameTime = 0f;
    for (int i = 0; i < frameTimes.Length; i++)
    {
        avgFrameTime += frameTimes[i];
    }
    avgFrameTime /= frameTimes.Length;
    
    // æ ¹æ“šæ€§èƒ½èª¿æ•´é–“éš”
    if (avgFrameTime > 0.016f) // å¦‚æœå¹€æ™‚é–“è¶…é16ms
    {
        adaptiveInterval = Mathf.Min(adaptiveInterval * 1.1f, maxUpdateInterval);
    }
    else
    {
        adaptiveInterval = Mathf.Max(adaptiveInterval * 0.95f, baseUpdateInterval);
    }
}
```

### 3. æ˜¾ç¤ºæ–¹å¼å¯¹æ¯”ï¼šRenderer vs RawImage

#### æ˜¾ç¤ºæ¨¡å¼æšä¸¾å®šä¹‰
```csharp
public enum DisplayMode
{
    Renderer,    // 3D Renderer æ¨¡å¼
    RawImage     // UI RawImage æ¨¡å¼
}
```

#### Renderer æ¨¡å¼å®ç°
```csharp
// é€‚ç”¨äº 3D ç‰©ä½“æ˜¾ç¤º
if (displayMode == DisplayMode.Renderer && targetRenderer != null)
{
    Material mat = targetRenderer.material;
    mat.mainTexture = tex;
    
    // ä½¿ç”¨ MaterialPropertyBlock ä¼˜åŒ–
    targetRenderer.GetPropertyBlock(_mpb);
    _mpb.SetTexture(ID_MainTex, tex);
    _mpb.SetTexture(ID_BaseMap, tex);
    targetRenderer.SetPropertyBlock(_mpb);
}
```

#### RawImage æ¨¡å¼å®ç°
```csharp
// é€‚ç”¨äº UI ç•Œé¢æ˜¾ç¤º
if (displayMode == DisplayMode.RawImage && targetRawImage != null)
{
    targetRawImage.texture = tex;
}
```

#### æ˜¾ç¤ºæ–¹å¼å¯¹æ¯”è¡¨

| ç‰¹æ€§ | Renderer æ¨¡å¼ | RawImage æ¨¡å¼ |
|------|---------------|---------------|
| **é€‚ç”¨åœºæ™¯** | 3D ç‰©ä½“ã€ä¸–ç•Œç©ºé—´ | UI ç•Œé¢ã€å±å¹•ç©ºé—´ |
| **è®¾ç½®å¤æ‚åº¦** | éœ€è¦ Material å’Œ Shader | ç›´æ¥è®¾ç½® texture |
| **æ€§èƒ½å¼€é”€** | è¾ƒé«˜ï¼ˆMaterial å¤„ç†ï¼‰ | è¾ƒä½ï¼ˆç›´æ¥èµ‹å€¼ï¼‰ |
| **Shader å…¼å®¹æ€§** | éœ€è¦å…¼å®¹æ€§å¤„ç† | æ— éœ€å¤„ç† |
| **UI å±‚çº§ç®¡ç†** | å— 3D ç©ºé—´é™åˆ¶ | çµæ´»ï¼ˆCanvas å±‚çº§ï¼‰ |
| **è°ƒè¯•éš¾åº¦** | è¾ƒå¤æ‚ | ç®€å•ç›´è§‚ |
| **å†…å­˜ä½¿ç”¨** | éœ€è¦ Material å¯¹è±¡ | ä»…éœ€ Texture |

#### RawImage é…ç½®æŒ‡å—

**Unity Inspector é…ç½®æ­¥éª¤ï¼š**

1. **åˆ›å»º UI Canvas**
   - åœ¨åœºæ™¯ä¸­åˆ›å»º Canvas
   - è®¾ç½® Canvas ä¸º Screen Space - Overlay

2. **æ·»åŠ  RawImage ç»„ä»¶**
   - åœ¨ Canvas ä¸‹åˆ›å»º UI â†’ Raw Image
   - è°ƒæ•´ RawImage çš„ RectTransform å¤§å°å’Œä½ç½®

3. **é…ç½®ç»„ä»¶å‚æ•°**
   - åœ¨ WebRTCScreenReceiver æˆ– ScreenCaptureHandler ä¸­
   - è®¾ç½® Display Mode ä¸º RawImage
   - å°† RawImage ç»„ä»¶æ‹–æ‹½åˆ° Target RawImage å­—æ®µ

4. **éªŒè¯é…ç½®**
   - è¿è¡Œåœºæ™¯ï¼Œæ£€æŸ¥è§†é¢‘æ˜¯å¦åœ¨ RawImage ä¸­æ˜¾ç¤º
   - æŸ¥çœ‹ Console æ—¥å¿—ç¡®è®¤æ¨¡å¼åˆ‡æ¢æˆåŠŸ

#### å…³é”®å®ç°ä»£ç 

**WebRTCScreenReceiver æ˜¾ç¤ºæ¨¡å¼æ”¯æŒï¼š**
```csharp
[Header("æ˜¾ç¤ºè®¾ç½®")]
public DisplayMode displayMode = DisplayMode.RawImage;
public Renderer targetRenderer;
public RawImage targetRawImage;

// æ£€æŸ¥æ˜¾ç¤ºç›®æ ‡è®¾ç½®
if (displayMode == DisplayMode.Renderer && targetRenderer == null)
{
    Debug.LogError("âŒ Renderer æ¨¡å¼ä½† targetRenderer æœªè®¾ç½®ï¼");
    return;
}
else if (displayMode == DisplayMode.RawImage && targetRawImage == null)
{
    Debug.LogError("âŒ RawImage æ¨¡å¼ä½† targetRawImage æœªè®¾ç½®ï¼");
    return;
}
```

**ScreenCaptureHandler æ˜¾ç¤ºæ¨¡å¼æ”¯æŒï¼š**
```csharp
[Header("æ˜¾ç¤ºè®¾ç½®")]
public DisplayMode displayMode = DisplayMode.RawImage;
public Renderer targetRenderer;
public RawImage targetRawImage;

// æ ¹æ®æ˜¾ç¤ºæ¨¡å¼åº”ç”¨çº¹ç†
if (displayMode == DisplayMode.RawImage && targetRawImage != null)
{
    targetRawImage.texture = screenTexture;
}
else if (displayMode == DisplayMode.Renderer && targetRenderer != null && screenMaterial != null)
{
    screenMaterial.mainTexture = screenTexture;
    targetRenderer.material = screenMaterial;
}
```

#### RawImage æ¨¡å¼ä¼˜åŠ¿

1. **ç®€åŒ–é…ç½®**: æ— éœ€åˆ›å»ºå’Œç®¡ç† Material å¯¹è±¡
2. **æ›´å¥½æ€§èƒ½**: ç›´æ¥çº¹ç†èµ‹å€¼ï¼Œæ— é¢å¤–æ¸²æŸ“å¼€é”€
3. **UI å‹å¥½**: å®Œç¾é€‚é… Unity UI ç³»ç»Ÿ
4. **æ˜“äºè°ƒè¯•**: ç›´è§‚çš„çº¹ç†æ˜¾ç¤ºï¼Œé—®é¢˜æ’æŸ¥ç®€å•
5. **çµæ´»å¸ƒå±€**: æ”¯æŒ Canvas çš„æ‰€æœ‰å¸ƒå±€å’ŒåŠ¨ç”»åŠŸèƒ½
6. **è·¨å¹³å°å…¼å®¹**: æ— éœ€è€ƒè™‘ä¸åŒå¹³å°çš„ Shader å…¼å®¹æ€§

## ğŸ› é‡è¦Bugä¿®å¾©è¨˜éŒ„

### Bug #1: WebRTCç´‹ç†ä¸é¡¯ç¤º
**ç—‡ç‹€**: WebRTCé€£æ¥æˆåŠŸä½†Unityä¸­è¦–é »ç´‹ç†ä¸é¡¯ç¤º  
**åŸå› åˆ†æ**: 
1. Shaderä¸åŒ¹é…å°è‡´ç´‹ç†ç„¡æ³•æ­£ç¢ºæ¸²æŸ“
2. MaterialPropertyBlockè¨­ç½®ä¸å®Œæ•´
3. ä¸»ç·šç¨‹èˆ‡WebRTCç·šç¨‹çš„ç´‹ç†æ›´æ–°è¡çª

**è§£æ±ºæ–¹æ¡ˆ**:
```csharp
// ç¢ºä¿ä½¿ç”¨æ­£ç¢ºçš„Shader
Shader shader = Shader.Find("Unlit/Texture");
if (shader == null) shader = Shader.Find("Universal Render Pipeline/Unlit");
mat.shader = shader;

// ä¸»ç·šç¨‹ç´‹ç†æ›´æ–°
vtrack.OnVideoReceived += (tex) => {
    _pendingTex = tex;
    _hasNewTex = true; // æ¨™è¨˜æœ‰æ–°ç´‹ç†
};

// åœ¨Updateä¸­è™•ç†ç´‹ç†æ›´æ–°
void Update()
{
    if (_hasNewTex && _pendingTex != null)
    {
        ApplyTextureWithMPB(_pendingTex);
        _hasNewTex = false;
    }
}
```

### Bug #2: ä¿¡ä»¤è½‰ç™¼å¤±æ•—
**ç—‡ç‹€**: WebRTCä¿¡ä»¤ç„¡æ³•æ­£ç¢ºè½‰ç™¼åˆ°Unityç«¯  
**åŸå› åˆ†æ**: 
1. ä¼ºæœå™¨ç«¯ä¿¡ä»¤è½‰ç™¼é‚è¼¯éŒ¯èª¤
2. JSONåºåˆ—åŒ–æ ¼å¼ä¸åŒ¹é…
3. æˆ¿é–“é…å°æ©Ÿåˆ¶å•é¡Œ

**è§£æ±ºæ–¹æ¡ˆ**:
```javascript
// ä¿®æ­£ä¿¡ä»¤è½‰ç™¼é‚è¼¯
if (['offer', 'answer', 'candidate'].includes(msg.type)) {
    const peers = rooms.get(ws.room) || new Set();
    
    for (const peer of peers) {
        if (peer !== ws && peer.readyState === WebSocket.OPEN) {
            // ç¢ºä¿ç™¼é€åŸå§‹ JSON å­—ç¬¦ä¸²
            peer.send(JSON.stringify(msg));
        }
    }
}
```

### Bug #3: è¨˜æ†¶é«”æ´©æ¼å•é¡Œ
**ç—‡ç‹€**: Unityç«¯è¨˜æ†¶é«”ä½¿ç”¨é‡æŒçºŒå¢é•·  
**åŸå› åˆ†æ**: 
1. Texture2Dç‰©ä»¶æ²’æœ‰æ­£ç¢ºé‡ç”¨
2. äº‹ä»¶è¨‚é–±æ²’æœ‰æ­£ç¢ºå–æ¶ˆ
3. ä½‡åˆ—å¤§å°æ²’æœ‰é™åˆ¶

**è§£æ±ºæ–¹æ¡ˆ**:
```csharp
// Texture2Dé‡ç”¨
if (screenTexture == null)
{
    screenTexture = new Texture2D(2, 2, TextureFormat.RGBA32, false);
}

// ä½‡åˆ—å¤§å°é™åˆ¶
if (frameQueue.Count >= maxQueueSize)
{
    frameQueue.TryDequeue(out _); // ä¸Ÿæ£„èˆŠå¹€
}

// æ­£ç¢ºçš„äº‹ä»¶æ¸…ç†
void OnDestroy()
{
    GyroscopeReceiver.OnScreenCaptureReceived -= HandleScreenFrame;
    CleanupWebRTC();
}
```

## ğŸ“Š æ€§èƒ½æ¸¬è©¦çµæœ

### å»¶é²æ¸¬è©¦
| å‚³è¼¸æ–¹å¼ | å¹³å‡å»¶é² | æœ€å°å»¶é² | æœ€å¤§å»¶é² | ç©©å®šæ€§ |
|---------|---------|---------|---------|--------|
| WebRTC P2P | 150ms | 100ms | 300ms | 85% |
| WebSocket é™ç´š | 600ms | 400ms | 1000ms | 95% |

### é »å¯¬ä½¿ç”¨æ¸¬è©¦
| è§£æåº¦ | WebRTC ä½å…ƒç‡ | WebSocket ä½å…ƒç‡ | å“è³ªè©•ä¼° |
|--------|-------------|----------------|----------|
| 1280x720 | 800-1200 kbps | 400-600 kbps | è‰¯å¥½ |
| 1920x1080 | 1500-2500 kbps | 800-1200 kbps | å„ªç§€ |

### è¨˜æ†¶é«”ä½¿ç”¨æ¸¬è©¦
| çµ„ä»¶ | åˆå§‹è¨˜æ†¶é«” | é‹è¡Œ1å°æ™‚ | å¢é•·ç‡ |
|------|----------|----------|--------|
| Unity WebRTC | 50MB | 65MB | +30% |
| Unity WebSocket | 30MB | 45MB | +50% |
| ç€è¦½å™¨ç«¯ | 80MB | 120MB | +50% |

## ğŸ”§ é…ç½®åƒæ•¸èªªæ˜

### å‰ç«¯é…ç½®
```javascript
// WebRTC é…ç½®
const rtcConfig = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' }
    ],
    iceCandidatePoolSize: 10
};

// è¢å¹•æ•ç²é…ç½®
const captureConfig = {
    video: {
        width: { ideal: 1280 },
        height: { ideal: 720 },
        frameRate: { ideal: 30, max: 30 }
    },
    audio: false
};
```

### Unityé…ç½®
```csharp
[Header("æ€§èƒ½è¨­å®š")]
public int maxQueueSize = 1; // æ¸›å°‘åˆ°1ï¼Œæœ€ä½å»¶é²
public float baseUpdateInterval = 0.033f; // 30fps base
public float maxUpdateInterval = 0.1f; // æœ€å¤§10fps
public float connectionTimeout = 18f; // é€£æ¥è¶…æ™‚æ™‚é–“

[Header("æ˜¾ç¤ºè®¾ç½®")]
public DisplayMode displayMode = DisplayMode.RawImage; // æ˜¾ç¤ºæ¨¡å¼é€‰æ‹©
public Renderer targetRenderer; // 3D Renderer ç›®æ ‡
public RawImage targetRawImage; // UI RawImage ç›®æ ‡
public Material screenMaterial; // å±å¹•æè´¨ï¼ˆRendereræ¨¡å¼ä½¿ç”¨ï¼‰
```

### ä¼ºæœå™¨é…ç½®
```javascript
// æˆ¿é–“ç®¡ç†é…ç½®
const ROOM_SIZE_LIMIT = 2; // æ¯å€‹æˆ¿é–“æœ€å¤š2å€‹å®¢æˆ¶ç«¯
const CONNECTION_TIMEOUT = 30000; // 30ç§’é€£æ¥è¶…æ™‚

// çµ±è¨ˆé…ç½®
const STATS_INTERVAL = 60000; // 1åˆ†é˜çµ±è¨ˆé–“éš”
const CLEANUP_INTERVAL = 30000; // 30ç§’æ¸…ç†é–“éš”
```

## ğŸš€ éƒ¨ç½²é…ç½®

### Railway éƒ¨ç½²é…ç½®
```toml
# railway.toml
[build]
builder = "NIXPACKS"

[deploy]
startCommand = "npm start"
healthcheckPath = "/health"
restartPolicyType = "ON_FAILURE"
restartPolicyMaxRetries = 3

[env]
NODE_ENV = "production"
PORT = "${{ PORT }}"
```

### ç’°å¢ƒè®Šæ•¸é…ç½®
```bash
# Railway è‡ªå‹•é…ç½®
PORT=è‡ªå‹•åˆ†é…
RAILWAY_STATIC_URL=è‡ªå‹•ç”Ÿæˆ

# å¯é¸é…ç½®
WEBRTC_STUN_SERVERS=stun:stun.l.google.com:19302,stun:stun1.l.google.com:19302
MAX_CONNECTIONS=100
ROOM_TIMEOUT=300000
```

## ğŸ“ˆ ç›£æ§èˆ‡èª¿è©¦

### å‰ç«¯ç›£æ§æŒ‡æ¨™
```javascript
// WebRTC çµ±è¨ˆæ•¸æ“š
const stats = {
    bitrate: 0,      // ä½å…ƒç‡ (kbps)
    fps: 0,          // å¹€ç‡ (fps)
    rtt: 0,          // å¾€è¿”æ™‚é–“ (ms)
    candidateType: 'unknown' // ICE å€™é¸è€…é¡å‹
};

// è¢å¹•æ•ç²çµ±è¨ˆ
const captureStats = {
    frameCount: 0,           // ç¸½å¹€æ•¸
    totalDataSize: 0,        // ç¸½æ•¸æ“šå¤§å°
    averageFPS: 0,           // å¹³å‡å¹€ç‡
    compressionRatio: 0      // å£“ç¸®æ¯”
};
```

### Unity èª¿è©¦ç•Œé¢
```csharp
void OnGUI()
{
    if (showDebugInfo && Application.isPlaying)
    {
        GUILayout.BeginArea(new Rect(10, 400, 300, 200));
        GUILayout.Label($"WebRTC æ¨¡å¼: {isWebRTCMode}");
        GUILayout.Label($"é€£æ¥ç‹€æ…‹: {isConnected}");
        GUILayout.Label($"è¦–é »ç´‹ç†: {(_pendingTex != null ? $"{_pendingTex.width}x{_pendingTex.height}" : "ç„¡")}");
        if (peerConnection != null)
        {
            GUILayout.Label($"ICE ç‹€æ…‹: {peerConnection.IceConnectionState}");
            GUILayout.Label($"é€£æ¥ç‹€æ…‹: {peerConnection.ConnectionState}");
        }
        GUILayout.EndArea();
    }
}
```

### ä¼ºæœå™¨ç«¯ç›£æ§
```javascript
// å¥åº·æª¢æŸ¥ç«¯é»
app.get('/health', (req, res) => {
    res.json({
        status: 'ok',
        uptime: Math.floor((Date.now() - stats.startTime) / 1000),
        connections: {
            active: stats.activeConnections,
            total: stats.totalConnections
        },
        messages: {
            total: stats.totalMessages,
            gyroscope: stats.gyroscopeMessages,
            shake: stats.shakeMessages,
            screenCapture: stats.screenCaptureMessages
        }
    });
});
```

## ğŸ”® æœªä¾†å„ªåŒ–æ–¹å‘

### çŸ­æœŸå„ªåŒ– (1-2é€±)
- [ ] **ç·¨ç¢¼å„ªåŒ–**: å¯¦ç¾ H.264 ç¡¬é«”ç·¨ç¢¼æ”¯æ´
- [ ] **è‡ªé©æ‡‰å“è³ª**: æ ¹æ“šç¶²è·¯ç‹€æ³å‹•æ…‹èª¿æ•´è§£æåº¦å’Œå¹€ç‡
- [ ] **éŒ¯èª¤æ¢å¾©**: æ”¹é€² WebRTC é€£æ¥å¤±æ•—å¾Œçš„è‡ªå‹•æ¢å¾©æ©Ÿåˆ¶
- [ ] **è¨˜æ†¶é«”å„ªåŒ–**: é€²ä¸€æ­¥æ¸›å°‘ Unity ç«¯çš„è¨˜æ†¶é«”ä½¿ç”¨

### ä¸­æœŸå„ªåŒ– (1å€‹æœˆ)
- [ ] **å¤šæˆ¿é–“æ”¯æ´**: æ”¯æ´å¤šå€‹æˆ¿é–“åŒæ™‚é€²è¡Œè¢å¹•æ•ç²
- [ ] **éŸ³é »å‚³è¼¸**: å¢åŠ éŸ³é »è»Œé“æ”¯æ´
- [ ] **éŒ„è£½åŠŸèƒ½**: æ·»åŠ æœ¬åœ°éŒ„è£½å’Œå›æ”¾åŠŸèƒ½
- [ ] **é›²ç«¯è½‰ç¢¼**: ä½¿ç”¨é›²ç«¯æœå‹™é€²è¡Œè¦–é »è½‰ç¢¼å„ªåŒ–

### é•·æœŸå„ªåŒ– (3å€‹æœˆ)
- [ ] **AI å¢å¼·**: ä½¿ç”¨ AI é€²è¡Œè¦–é »å“è³ªå„ªåŒ–å’Œé™å™ª
- [ ] **é‚Šç·£è¨ˆç®—**: éƒ¨ç½²é‚Šç·£ç¯€é»æ¸›å°‘å»¶é²
- [ ] **å¤šå¹³å°æ”¯æ´**: æ“´å±•åˆ°æ›´å¤šå¹³å°å’Œè¨­å‚™
- [ ] **ä¼æ¥­ç´šåŠŸèƒ½**: æ·»åŠ ç”¨æˆ¶ç®¡ç†ã€æ¬Šé™æ§åˆ¶ç­‰åŠŸèƒ½

## ğŸ’¡ é–‹ç™¼å¿ƒå¾—èˆ‡æœ€ä½³å¯¦è¸

### æŠ€è¡“å­¸ç¿’æ”¶ç©«
1. **WebRTC è¤‡é›œæ€§**: ä¿¡ä»¤è™•ç†å’Œ ICE é€£æ¥æ¯”é æœŸè¤‡é›œï¼Œéœ€è¦ä»”ç´°è™•ç†å„ç¨®ç‹€æ…‹è½‰æ›
2. **æ€§èƒ½å¹³è¡¡**: åœ¨å“è³ªã€å»¶é²ã€é »å¯¬ä¹‹é–“æ‰¾åˆ°æœ€ä½³å¹³è¡¡é»éœ€è¦å¤§é‡æ¸¬è©¦
3. **é™ç´šç­–ç•¥**: å®Œå–„çš„é™ç´šæ©Ÿåˆ¶æ˜¯ç¢ºä¿ç³»çµ±ç©©å®šæ€§çš„é—œéµ
4. **è·¨å¹³å°å…¼å®¹**: ä¸åŒç€è¦½å™¨å’Œå¹³å°çš„ WebRTC æ”¯æ´å·®ç•°å¾ˆå¤§

### æœ€ä½³å¯¦è¸ç¸½çµ
1. **æ¨¡çµ„åŒ–è¨­è¨ˆ**: å°‡ WebRTC å’Œ WebSocket åŠŸèƒ½åˆ†é›¢ï¼Œä¾¿æ–¼ç¶­è­·å’Œèª¿è©¦
2. **éŒ¯èª¤è™•ç†**: å®Œå–„çš„éŒ¯èª¤è™•ç†å’Œæ—¥èªŒè¨˜éŒ„æ˜¯èª¿è©¦çš„é—œéµ
3. **æ€§èƒ½ç›£æ§**: å³æ™‚ç›£æ§å„ç¨®æ€§èƒ½æŒ‡æ¨™ï¼ŒåŠæ™‚ç™¼ç¾å•é¡Œ
4. **ç”¨æˆ¶é«”é©—**: è‡ªå‹•é™ç´šå’Œæ™ºèƒ½é‡é€£æ©Ÿåˆ¶æå‡ç”¨æˆ¶é«”é©—
5. **è³‡æºç®¡ç†**: æ­£ç¢ºçš„è³‡æºæ¸…ç†å’Œè¨˜æ†¶é«”ç®¡ç†é¿å…æ´©æ¼

### é‡è¦æŠ€è¡“æ±ºç­–å›é¡§
1. **é¸æ“‡ WebRTC P2P å„ªå…ˆ**: é›–ç„¶å¯¦ç¾è¤‡é›œï¼Œä½†æä¾›äº†æœ€ä½å»¶é²
2. **å¯¦ç¾é›™è·¯å¾‘è¨­è¨ˆ**: ç¢ºä¿ç³»çµ±çš„å¯é æ€§å’Œç©©å®šæ€§
3. **ä½¿ç”¨æˆ¿é–“é…å°ç³»çµ±**: ç°¡åŒ–äº†å¤šå°ç«¯é€£æ¥ç®¡ç†
4. **å„ªåŒ–ç´‹ç†è™•ç†**: ä½¿ç”¨ MaterialPropertyBlock æå‡æ€§èƒ½
5. **å¯¦ç¾è‡ªé©æ‡‰å¹€ç‡**: æ ¹æ“šç³»çµ±æ€§èƒ½å‹•æ…‹èª¿æ•´æ›´æ–°é »ç‡

---

**æœ€å¾Œæ›´æ–°**: 2024å¹´10æœˆ18æ—¥  
**è¨˜éŒ„è€…**: é–‹ç™¼åœ˜éšŠ  
**ä¸‹æ¬¡æ›´æ–°**: å®Œæˆæ–°åŠŸèƒ½æˆ–é‡è¦å„ªåŒ–æ™‚æ›´æ–°  
**ç›¸é—œæ–‡ä»¶**: [README.md](README.md), [TROUBLESHOOTING.md](TROUBLESHOOTING.md), [WEBRTC_SETUP.md](WEBRTC_SETUP.md)
